import {
  require_build as require_build4,
  require_graceful_fs,
  require_path,
  require_url,
  require_util
} from "./chunk-MIQHJWNR.js";
import "./chunk-2FC3WXEE.js";
import {
  require_build,
  require_build2,
  require_build3
} from "./chunk-3WCLC3CI.js";
import {
  require_browser,
  require_color_convert
} from "./chunk-4K4JBLLW.js";
import {
  __commonJS,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/@jest/expect-utils/build/index.js
var require_build5 = __commonJS({
  "node_modules/@jest/expect-utils/build/index.js"(exports, module) {
    (() => {
      "use strict";
      var __webpack_modules__ = {
        /***/
        "./src/immutableUtils.ts": (
          /***/
          (__unused_webpack_module, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isImmutableList = isImmutableList;
            exports2.isImmutableOrderedKeyed = isImmutableOrderedKeyed;
            exports2.isImmutableOrderedSet = isImmutableOrderedSet;
            exports2.isImmutableRecord = isImmutableRecord;
            exports2.isImmutableUnorderedKeyed = isImmutableUnorderedKeyed;
            exports2.isImmutableUnorderedSet = isImmutableUnorderedSet;
            const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
            const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
            const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
            const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
            const IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
            function isObjectLiteral(source) {
              return source != null && typeof source === "object" && !Array.isArray(source);
            }
            function isImmutableUnorderedKeyed(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && !source[IS_ORDERED_SENTINEL]);
            }
            function isImmutableUnorderedSet(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && !source[IS_ORDERED_SENTINEL]);
            }
            function isImmutableList(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL]);
            }
            function isImmutableOrderedKeyed(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && source[IS_ORDERED_SENTINEL]);
            }
            function isImmutableOrderedSet(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && source[IS_ORDERED_SENTINEL]);
            }
            function isImmutableRecord(source) {
              return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL]);
            }
          }
        ),
        /***/
        "./src/index.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _exportNames = {
              equals: true,
              isA: true
            };
            Object.defineProperty(exports2, "equals", {
              enumerable: true,
              get: function() {
                return _jasmineUtils.equals;
              }
            });
            Object.defineProperty(exports2, "isA", {
              enumerable: true,
              get: function() {
                return _jasmineUtils.isA;
              }
            });
            var _jasmineUtils = __webpack_require__2("./src/jasmineUtils.ts");
            var _utils = __webpack_require__2("./src/utils.ts");
            Object.keys(_utils).forEach(function(key) {
              if (key === "default" || key === "__esModule") return;
              if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
              if (key in exports2 && exports2[key] === _utils[key]) return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _utils[key];
                }
              });
            });
          }
        ),
        /***/
        "./src/jasmineUtils.ts": (
          /***/
          (__unused_webpack_module, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.equals = void 0;
            exports2.isA = isA;
            const equals = (a, b, customTesters, strictCheck) => {
              customTesters = customTesters || [];
              return eq(a, b, [], [], customTesters, strictCheck);
            };
            exports2.equals = equals;
            function isAsymmetric(obj) {
              return !!obj && isA("Function", obj.asymmetricMatch);
            }
            function asymmetricMatch(a, b) {
              const asymmetricA = isAsymmetric(a);
              const asymmetricB = isAsymmetric(b);
              if (asymmetricA && asymmetricB) {
                return void 0;
              }
              if (asymmetricA) {
                return a.asymmetricMatch(b);
              }
              if (asymmetricB) {
                return b.asymmetricMatch(a);
              }
            }
            function eq(a, b, aStack, bStack, customTesters, strictCheck) {
              let result = true;
              const asymmetricResult = asymmetricMatch(a, b);
              if (asymmetricResult !== void 0) {
                return asymmetricResult;
              }
              const testerContext = {
                equals
              };
              for (const item of customTesters) {
                const customTesterResult = item.call(testerContext, a, b, customTesters);
                if (customTesterResult !== void 0) {
                  return customTesterResult;
                }
              }
              if (a instanceof Error && b instanceof Error) {
                return a.message === b.message;
              }
              if (Object.is(a, b)) {
                return true;
              }
              if (a === null || b === null) {
                return false;
              }
              const className = Object.prototype.toString.call(a);
              if (className !== Object.prototype.toString.call(b)) {
                return false;
              }
              switch (className) {
                case "[object Boolean]":
                case "[object String]":
                case "[object Number]":
                  if (typeof a !== typeof b) {
                    return false;
                  } else if (typeof a !== "object" && typeof b !== "object") {
                    return false;
                  } else {
                    return Object.is(a.valueOf(), b.valueOf());
                  }
                case "[object Date]":
                  return +a === +b;
                case "[object RegExp]":
                  return a.source === b.source && a.flags === b.flags;
                case "[object URL]":
                  return a.href === b.href;
              }
              if (typeof a !== "object" || typeof b !== "object") {
                return false;
              }
              if (isDomNode(a) && isDomNode(b)) {
                return a.isEqualNode(b);
              }
              let length = aStack.length;
              while (length--) {
                if (aStack[length] === a) {
                  return bStack[length] === b;
                } else if (bStack[length] === b) {
                  return false;
                }
              }
              aStack.push(a);
              bStack.push(b);
              if (strictCheck && className === "[object Array]" && a.length !== b.length) {
                return false;
              }
              const aKeys = keys(a, hasKey);
              let key;
              const bKeys = keys(b, hasKey);
              if (!strictCheck) {
                for (let index = 0; index !== bKeys.length; ++index) {
                  key = bKeys[index];
                  if ((isAsymmetric(b[key]) || b[key] === void 0) && !hasKey(a, key)) {
                    aKeys.push(key);
                  }
                }
                for (let index = 0; index !== aKeys.length; ++index) {
                  key = aKeys[index];
                  if ((isAsymmetric(a[key]) || a[key] === void 0) && !hasKey(b, key)) {
                    bKeys.push(key);
                  }
                }
              }
              let size = aKeys.length;
              if (bKeys.length !== size) {
                return false;
              }
              while (size--) {
                key = aKeys[size];
                if (strictCheck) result = hasKey(b, key) && eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);
                else result = (hasKey(b, key) || isAsymmetric(a[key]) || a[key] === void 0) && eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);
                if (!result) {
                  return false;
                }
              }
              aStack.pop();
              bStack.pop();
              return result;
            }
            function keys(obj, hasKey2) {
              const keys2 = [];
              for (const key in obj) {
                if (hasKey2(obj, key)) {
                  keys2.push(key);
                }
              }
              return [...keys2, ...Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable)];
            }
            function hasKey(obj, key) {
              return Object.prototype.hasOwnProperty.call(obj, key);
            }
            function isA(typeName, value) {
              return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
            }
            function isDomNode(obj) {
              return obj !== null && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string" && typeof obj.isEqualNode === "function";
            }
          }
        ),
        /***/
        "./src/utils.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.arrayBufferEquality = void 0;
            exports2.emptyObject = emptyObject;
            exports2.typeEquality = exports2.subsetEquality = exports2.sparseArrayEquality = exports2.pathAsArray = exports2.partition = exports2.iterableEquality = exports2.isOneline = exports2.isError = exports2.getPath = exports2.getObjectSubset = exports2.getObjectKeys = void 0;
            var _getType = require_build();
            var _immutableUtils = __webpack_require__2("./src/immutableUtils.ts");
            var _jasmineUtils = __webpack_require__2("./src/jasmineUtils.ts");
            var Symbol = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
            const hasPropertyInObject = (object, key) => {
              const shouldTerminate = !object || typeof object !== "object" || object === Object.prototype;
              if (shouldTerminate) {
                return false;
              }
              return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
            };
            const getObjectKeys = (object) => {
              return [...Object.keys(object), ...Object.getOwnPropertySymbols(object).filter((s) => Object.getOwnPropertyDescriptor(object, s)?.enumerable)];
            };
            exports2.getObjectKeys = getObjectKeys;
            const getPath = (object, propertyPath) => {
              if (!Array.isArray(propertyPath)) {
                propertyPath = pathAsArray(propertyPath);
              }
              if (propertyPath.length > 0) {
                const lastProp = propertyPath.length === 1;
                const prop = propertyPath[0];
                const newObject = object[prop];
                if (!lastProp && (newObject === null || newObject === void 0)) {
                  return {
                    hasEndProp: false,
                    lastTraversedObject: object,
                    traversedPath: []
                  };
                }
                const result = getPath(newObject, propertyPath.slice(1));
                if (result.lastTraversedObject === null) {
                  result.lastTraversedObject = object;
                }
                result.traversedPath.unshift(prop);
                if (lastProp) {
                  result.endPropIsDefined = !(0, _getType.isPrimitive)(object) && prop in object;
                  result.hasEndProp = newObject !== void 0 || result.endPropIsDefined;
                  if (!result.hasEndProp) {
                    result.traversedPath.shift();
                  }
                }
                return result;
              }
              return {
                lastTraversedObject: null,
                traversedPath: [],
                value: object
              };
            };
            exports2.getPath = getPath;
            const getObjectSubset = (object, subset, customTesters = [], seenReferences = /* @__PURE__ */ new WeakMap()) => {
              if (Array.isArray(object)) {
                if (Array.isArray(subset) && subset.length === object.length) {
                  return subset.map((sub, i) => getObjectSubset(object[i], sub, customTesters));
                }
              } else if (object instanceof Date) {
                return object;
              } else if (isObject(object) && isObject(subset)) {
                if ((0, _jasmineUtils.equals)(object, subset, [...customTesters, iterableEquality, subsetEquality])) {
                  return subset;
                }
                const trimmed = {};
                seenReferences.set(object, trimmed);
                for (const key of getObjectKeys(object).filter((key2) => hasPropertyInObject(subset, key2))) {
                  trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : getObjectSubset(object[key], subset[key], customTesters, seenReferences);
                }
                if (getObjectKeys(trimmed).length > 0) {
                  return trimmed;
                }
              }
              return object;
            };
            exports2.getObjectSubset = getObjectSubset;
            const IteratorSymbol = Symbol.iterator;
            const hasIterator = (object) => !!(object != null && object[IteratorSymbol]);
            const iterableEquality = (a, b, customTesters = [], aStack = [], bStack = []) => {
              if (typeof a !== "object" || typeof b !== "object" || Array.isArray(a) || Array.isArray(b) || ArrayBuffer.isView(a) || ArrayBuffer.isView(b) || !hasIterator(a) || !hasIterator(b)) {
                return void 0;
              }
              if (a.constructor !== b.constructor) {
                return false;
              }
              let length = aStack.length;
              while (length--) {
                if (aStack[length] === a) {
                  return bStack[length] === b;
                }
              }
              aStack.push(a);
              bStack.push(b);
              const iterableEqualityWithStack = (a2, b2) => iterableEquality(a2, b2, [...filteredCustomTesters], [...aStack], [...bStack]);
              const filteredCustomTesters = [...customTesters.filter((t) => t !== iterableEquality), iterableEqualityWithStack];
              if (a.size !== void 0) {
                if (a.size !== b.size) {
                  return false;
                } else if ((0, _jasmineUtils.isA)("Set", a) || (0, _immutableUtils.isImmutableUnorderedSet)(a)) {
                  let allFound = true;
                  for (const aValue of a) {
                    if (!b.has(aValue)) {
                      let has = false;
                      for (const bValue of b) {
                        const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, filteredCustomTesters);
                        if (isEqual === true) {
                          has = true;
                        }
                      }
                      if (has === false) {
                        allFound = false;
                        break;
                      }
                    }
                  }
                  aStack.pop();
                  bStack.pop();
                  return allFound;
                } else if ((0, _jasmineUtils.isA)("Map", a) || (0, _immutableUtils.isImmutableUnorderedKeyed)(a)) {
                  let allFound = true;
                  for (const aEntry of a) {
                    if (!b.has(aEntry[0]) || !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), filteredCustomTesters)) {
                      let has = false;
                      for (const bEntry of b) {
                        const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], filteredCustomTesters);
                        let matchedValue = false;
                        if (matchedKey === true) {
                          matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], filteredCustomTesters);
                        }
                        if (matchedValue === true) {
                          has = true;
                        }
                      }
                      if (has === false) {
                        allFound = false;
                        break;
                      }
                    }
                  }
                  aStack.pop();
                  bStack.pop();
                  return allFound;
                }
              }
              const bIterator = b[IteratorSymbol]();
              for (const aValue of a) {
                const nextB = bIterator.next();
                if (nextB.done || !(0, _jasmineUtils.equals)(aValue, nextB.value, filteredCustomTesters)) {
                  return false;
                }
              }
              if (!bIterator.next().done) {
                return false;
              }
              if (!(0, _immutableUtils.isImmutableList)(a) && !(0, _immutableUtils.isImmutableOrderedKeyed)(a) && !(0, _immutableUtils.isImmutableOrderedSet)(a) && !(0, _immutableUtils.isImmutableRecord)(a)) {
                const aEntries = entries(a);
                const bEntries = entries(b);
                if (!(0, _jasmineUtils.equals)(aEntries, bEntries)) {
                  return false;
                }
              }
              aStack.pop();
              bStack.pop();
              return true;
            };
            exports2.iterableEquality = iterableEquality;
            const entries = (obj) => {
              if (!isObject(obj)) return [];
              const symbolProperties = Object.getOwnPropertySymbols(obj).filter((key) => key !== Symbol.iterator).map((key) => [key, obj[key]]);
              return [...symbolProperties, ...Object.entries(obj)];
            };
            const isObject = (a) => a !== null && typeof a === "object";
            const isObjectWithKeys = (a) => isObject(a) && !(a instanceof Error) && !Array.isArray(a) && !(a instanceof Date) && !(a instanceof Set) && !(a instanceof Map);
            const subsetEquality = (object, subset, customTesters = []) => {
              const filteredCustomTesters = customTesters.filter((t) => t !== subsetEquality);
              const subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
                if (!isObjectWithKeys(subset2)) {
                  return void 0;
                }
                if (seenReferences.has(subset2)) return void 0;
                seenReferences.set(subset2, true);
                const matchResult = getObjectKeys(subset2).every((key) => {
                  if (isObjectWithKeys(subset2[key])) {
                    if (seenReferences.has(subset2[key])) {
                      return (0, _jasmineUtils.equals)(object2[key], subset2[key], filteredCustomTesters);
                    }
                  }
                  const result = object2 != null && hasPropertyInObject(object2, key) && (0, _jasmineUtils.equals)(object2[key], subset2[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
                  seenReferences.delete(subset2[key]);
                  return result;
                });
                seenReferences.delete(subset2);
                return matchResult;
              };
              return subsetEqualityWithContext()(object, subset);
            };
            exports2.subsetEquality = subsetEquality;
            const typeEquality = (a, b) => {
              if (a == null || b == null || a.constructor === b.constructor || // Since Jest globals are different from Node globals,
              // constructors are different even between arrays when comparing properties of mock objects.
              // Both of them should be able to compare correctly when they are array-to-array.
              // https://github.com/jestjs/jest/issues/2549
              Array.isArray(a) && Array.isArray(b)) {
                return void 0;
              }
              return false;
            };
            exports2.typeEquality = typeEquality;
            const arrayBufferEquality = (a, b) => {
              let dataViewA = a;
              let dataViewB = b;
              if (isArrayBuffer(a) && isArrayBuffer(b)) {
                dataViewA = new DataView(a);
                dataViewB = new DataView(b);
              } else if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
                dataViewA = new DataView(a.buffer, a.byteOffset, a.byteLength);
                dataViewB = new DataView(b.buffer, b.byteOffset, b.byteLength);
              }
              if (!(dataViewA instanceof DataView && dataViewB instanceof DataView)) {
                return void 0;
              }
              if (dataViewA.byteLength !== dataViewB.byteLength) {
                return false;
              }
              for (let i = 0; i < dataViewA.byteLength; i++) {
                if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {
                  return false;
                }
              }
              return true;
            };
            exports2.arrayBufferEquality = arrayBufferEquality;
            function isArrayBuffer(obj) {
              return Object.prototype.toString.call(obj) === "[object ArrayBuffer]";
            }
            const sparseArrayEquality = (a, b, customTesters = []) => {
              if (!Array.isArray(a) || !Array.isArray(b)) {
                return void 0;
              }
              const aKeys = Object.keys(a);
              const bKeys = Object.keys(b);
              return (0, _jasmineUtils.equals)(a, b, customTesters.filter((t) => t !== sparseArrayEquality), true) && (0, _jasmineUtils.equals)(aKeys, bKeys);
            };
            exports2.sparseArrayEquality = sparseArrayEquality;
            const partition = (items, predicate) => {
              const result = [[], []];
              for (const item of items) result[predicate(item) ? 0 : 1].push(item);
              return result;
            };
            exports2.partition = partition;
            const pathAsArray = (propertyPath) => {
              const properties = [];
              if (propertyPath === "") {
                properties.push("");
                return properties;
              }
              const pattern = new RegExp("[^.[\\]]+|(?=(?:\\.)(?:\\.|$))", "g");
              if (propertyPath[0] === ".") {
                properties.push("");
              }
              propertyPath.replaceAll(pattern, (match) => {
                properties.push(match);
                return match;
              });
              return properties;
            };
            exports2.pathAsArray = pathAsArray;
            const isError = (value) => {
              switch (Object.prototype.toString.call(value)) {
                case "[object Error]":
                case "[object Exception]":
                case "[object DOMException]":
                  return true;
                default:
                  return value instanceof Error;
              }
            };
            exports2.isError = isError;
            function emptyObject(obj) {
              return obj && typeof obj === "object" ? Object.keys(obj).length === 0 : false;
            }
            const MULTILINE_REGEXP = /[\n\r]/;
            const isOneline = (expected, received) => typeof expected === "string" && typeof received === "string" && (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));
            exports2.isOneline = isOneline;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      var __webpack_exports__ = __webpack_require__("./src/index.ts");
      module.exports = __webpack_exports__;
    })();
  }
});

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports, module) {
    var x = String;
    var create = function() {
      return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
    };
    module.exports = create();
    module.exports.createColors = create;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5]) token.type = "comment";
      else if (match[6]) token.type = "comment", token.closed = !!match[7];
      else if (match[8]) token.type = "regex";
      else if (match[9]) token.type = "number";
      else if (match[10]) token.type = "name";
      else if (match[11]) token.type = "punctuator";
      else if (match[12]) token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    var nonASCIIidentifierChars = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var picocolors = require_picocolors_browser();
    var jsTokens = require_js_tokens();
    var helperValidatorIdentifier = require_lib();
    function isColorSupported() {
      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors) {
      return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
      };
    }
    var defsOn = buildDefs(picocolors.createColors(true));
    var defsOff = buildDefs(picocolors.createColors(false));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = jsTokens.default.exec(text)) {
          const token = jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlight(text) {
      if (text === "") return "";
      const defs = getDefs(true);
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        if (type in defs) {
          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    var deprecationWarningShown = false;
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
      const defs = getDefs(shouldHighlight);
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
        const number = start + 1 + index2;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + defs.message(opts.message);
            }
          }
          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (shouldHighlight) {
        return defs.reset(frame);
      } else {
        return frame;
      }
    }
    function index(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = index;
    exports.highlight = highlight;
  }
});

// node_modules/jest-message-util/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/jest-message-util/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/jest-message-util/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/jest-message-util/node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      const node = block.nodes[n];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = (ast, options = {}) => {
      const stringify = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-") value = value.slice(1);
      if (value === "0") return false;
      while (value[++index] === "0") ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a === 0) a = 0;
      if (b === 0) b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          const child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: " ",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path = require_path();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require_path();
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path = require_path();
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/micromatch/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (v) => v === "" || v === "./";
    var hasBraces = (v) => {
      const index = v.indexOf("{");
      return index > -1 && v.indexOf("}", index) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult) options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module.exports = micromatch;
  }
});

// node_modules/slash/index.js
var require_slash = __commonJS({
  "node_modules/slash/index.js"(exports, module) {
    "use strict";
    module.exports = (path) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
      if (isExtendedLengthPath || hasNonAscii) {
        return path;
      }
      return path.replace(/\\/g, "/");
    };
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(
      require_module().builtinModules,
      "bootstrap_node",
      "node"
    ).map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(
      /\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,
      /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,
      /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/
    );
    var StackUtils = class _StackUtils {
      constructor(opts) {
        opts = {
          ignoredPackages: [],
          ...opts
        };
        if ("internals" in opts === false) {
          opts.internals = _StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(
          opts.internals,
          ignoredPackagesRegExp(opts.ignoredPackages)
        );
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp(
      "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
    );
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module.exports = StackUtils;
  }
});

// node_modules/jest-message-util/build/index.js
var require_build6 = __commonJS({
  "node_modules/jest-message-util/build/index.js"(exports, module) {
    (() => {
      "use strict";
      var __webpack_exports__ = {};
      (() => {
        var exports2 = __webpack_exports__;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.formatResultsErrors = exports2.formatPath = exports2.formatExecError = void 0;
        exports2.formatStackTrace = formatStackTrace;
        exports2.getStackTraceLines = getStackTraceLines;
        exports2.getTopFrame = getTopFrame;
        exports2.separateMessageFromStack = exports2.indentAllLines = void 0;
        var path = _interopRequireWildcard(require_path());
        var _url = require_url();
        var _util = require_util();
        var _codeFrame = require_lib2();
        var _chalk = _interopRequireDefault(require_source());
        var fs = _interopRequireWildcard(require_graceful_fs());
        var _micromatch = _interopRequireDefault(require_micromatch());
        var _slash = _interopRequireDefault(require_slash());
        var _stackUtils = _interopRequireDefault(require_stack_utils());
        var _prettyFormat = require_build2();
        function _interopRequireDefault(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function _interopRequireWildcard(e, t) {
          if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
          return (_interopRequireWildcard = function(e2, t2) {
            if (!t2 && e2 && e2.__esModule) return e2;
            var o, i, f = { __proto__: null, default: e2 };
            if (null === e2 || "object" != typeof e2 && "function" != typeof e2) return f;
            if (o = t2 ? n : r) {
              if (o.has(e2)) return o.get(e2);
              o.set(e2, f);
            }
            for (const t3 in e2) "default" !== t3 && {}.hasOwnProperty.call(e2, t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, t3)) && (i.get || i.set) ? o(f, t3, i) : f[t3] = e2[t3]);
            return f;
          })(e, t);
        }
        var Symbol = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
        var Symbol = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
        var jestReadFile = globalThis[Symbol.for("jest-native-read-file")] || fs.readFileSync;
        const stackUtils = new _stackUtils.default({
          cwd: "something which does not exist"
        });
        let nodeInternals = [];
        try {
          nodeInternals = _stackUtils.default.nodeInternals();
        } catch {
        }
        const PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;
        const PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`;
        const JASMINE_IGNORE = /^\s+at(?:(?:.jasmine-)|\s+jasmine\.buildExpectationResult)/;
        const JEST_INTERNALS_IGNORE = /^\s+at.*?jest(-.*?)?(\/|\\)(build|node_modules|packages)(\/|\\)/;
        const ANONYMOUS_FN_IGNORE = /^\s+at <anonymous>.*$/;
        const ANONYMOUS_PROMISE_IGNORE = /^\s+at (new )?Promise \(<anonymous>\).*$/;
        const ANONYMOUS_GENERATOR_IGNORE = /^\s+at Generator.next \(<anonymous>\).*$/;
        const NATIVE_NEXT_IGNORE = /^\s+at next \(native\).*$/;
        const TITLE_INDENT = "  ";
        const MESSAGE_INDENT = "    ";
        const STACK_INDENT = "      ";
        const ANCESTRY_SEPARATOR = " › ";
        const TITLE_BULLET = _chalk.default.bold("● ");
        const STACK_TRACE_COLOR = _chalk.default.dim;
        const STACK_PATH_REGEXP = /\s*at.*\(?(:\d*:\d*|native)\)?/;
        const EXEC_ERROR_MESSAGE = "Test suite failed to run";
        const NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;
        const indentAllLines = (lines) => lines.replaceAll(NOT_EMPTY_LINE_REGEXP, MESSAGE_INDENT);
        exports2.indentAllLines = indentAllLines;
        const trim = (string) => (string || "").trim();
        const trimPaths = (string) => STACK_PATH_REGEXP.test(string) ? trim(string) : string;
        const getRenderedCallsite = (fileContent, line, column) => {
          let renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {
            start: {
              column,
              line
            }
          }, {
            highlightCode: true
          });
          renderedCallsite = indentAllLines(renderedCallsite);
          renderedCallsite = `
${renderedCallsite}
`;
          return renderedCallsite;
        };
        const blankStringRegexp = /^\s*$/;
        function checkForCommonEnvironmentErrors(error) {
          if (error.includes("ReferenceError: document is not defined") || error.includes("ReferenceError: window is not defined") || error.includes("ReferenceError: navigator is not defined")) {
            return warnAboutWrongTestEnvironment(error, "jsdom");
          } else if (error.includes(".unref is not a function")) {
            return warnAboutWrongTestEnvironment(error, "node");
          }
          return error;
        }
        function warnAboutWrongTestEnvironment(error, env) {
          return _chalk.default.bold.red(`The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline("https://jestjs.io/docs/configuration#testenvironment-string")}.
Consider using the "${env}" test environment.

`) + error;
        }
        const formatExecError = (error, config, options, testPath, reuseMessage, noTitle) => {
          if (!error || typeof error === "number") {
            error = new Error(`Expected an Error, but "${String(error)}" was thrown`);
            error.stack = "";
          }
          let message, stack;
          let cause = "";
          const subErrors = [];
          if (typeof error === "string" || !error) {
            error ||= "EMPTY ERROR";
            message = "";
            stack = error;
          } else {
            message = error.message;
            stack = typeof error.stack === "string" ? error.stack : `thrown: ${(0, _prettyFormat.format)(error, {
              maxDepth: 3
            })}`;
            if ("cause" in error) {
              const prefix = "\n\nCause:\n";
              if (typeof error.cause === "string" || typeof error.cause === "number") {
                cause += `${prefix}${error.cause}`;
              } else if (_util.types.isNativeError(error.cause) || error.cause instanceof Error) {
                const formatted = formatExecError(error.cause, config, options, testPath, reuseMessage, true);
                cause += `${prefix}${formatted}`;
              }
            }
            if ("errors" in error && Array.isArray(error.errors)) {
              for (const subError of error.errors) {
                subErrors.push(formatExecError(subError, config, options, testPath, reuseMessage, true));
              }
            }
          }
          if (cause !== "") {
            cause = indentAllLines(cause);
          }
          const separated = separateMessageFromStack(stack || "");
          stack = separated.stack;
          if (separated.message.includes(trim(message))) {
            message = separated.message;
          }
          message = checkForCommonEnvironmentErrors(message);
          message = indentAllLines(message);
          stack = stack && !options.noStackTrace ? `
${formatStackTrace(stack, config, options, testPath)}` : "";
          if (typeof stack !== "string" || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {
            message = `thrown: ${(0, _prettyFormat.format)(error, {
              maxDepth: 3
            })}`;
          }
          let messageToUse;
          if (reuseMessage || noTitle) {
            messageToUse = ` ${message.trim()}`;
          } else {
            messageToUse = `${EXEC_ERROR_MESSAGE}

${message}`;
          }
          const title = noTitle ? "" : `${TITLE_INDENT + TITLE_BULLET}`;
          const subErrorStr = subErrors.length > 0 ? indentAllLines(`

Errors contained in AggregateError:
${subErrors.join("\n")}`) : "";
          return `${title + messageToUse + stack + cause + subErrorStr}
`;
        };
        exports2.formatExecError = formatExecError;
        const removeInternalStackEntries = (lines, options) => {
          let pathCounter = 0;
          return lines.filter((line) => {
            if (ANONYMOUS_FN_IGNORE.test(line)) {
              return false;
            }
            if (ANONYMOUS_PROMISE_IGNORE.test(line)) {
              return false;
            }
            if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {
              return false;
            }
            if (NATIVE_NEXT_IGNORE.test(line)) {
              return false;
            }
            if (nodeInternals.some((internal) => internal.test(line))) {
              return false;
            }
            if (!STACK_PATH_REGEXP.test(line)) {
              return true;
            }
            if (JASMINE_IGNORE.test(line)) {
              return false;
            }
            if (++pathCounter === 1) {
              return true;
            }
            if (options.noStackTrace) {
              return false;
            }
            if (JEST_INTERNALS_IGNORE.test(line)) {
              return false;
            }
            return true;
          });
        };
        const formatPath = (line, config, relativeTestPath = null) => {
          const match = line.match(/(^\s*at .*?\(?)([^()]+)(:\d+:\d+\)?.*$)/);
          if (!match) {
            return line;
          }
          let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2]));
          if (config.testMatch && config.testMatch.length > 0 && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {
            filePath = _chalk.default.reset.cyan(filePath);
          }
          return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);
        };
        exports2.formatPath = formatPath;
        function getStackTraceLines(stack, options) {
          options = {
            noCodeFrame: false,
            noStackTrace: false,
            ...options
          };
          return removeInternalStackEntries(stack.split(/\n/), options);
        }
        function getTopFrame(lines) {
          for (const line of lines) {
            if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {
              continue;
            }
            const parsedFrame = stackUtils.parseLine(line.trim());
            if (parsedFrame && parsedFrame.file) {
              if (parsedFrame.file.startsWith("file://")) {
                parsedFrame.file = (0, _slash.default)((0, _url.fileURLToPath)(parsedFrame.file));
              }
              return parsedFrame;
            }
          }
          return null;
        }
        function formatStackTrace(stack, config, options, testPath) {
          const lines = getStackTraceLines(stack, options);
          let renderedCallsite = "";
          const relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;
          if (!options.noStackTrace && !options.noCodeFrame) {
            const topFrame = getTopFrame(lines);
            if (topFrame) {
              const {
                column,
                file: filename,
                line
              } = topFrame;
              if (line && filename && path.isAbsolute(filename)) {
                let fileContent;
                try {
                  fileContent = jestReadFile(filename, "utf8");
                  renderedCallsite = getRenderedCallsite(fileContent, line, column);
                } catch {
                }
              }
            }
          }
          const stacktrace = lines.filter(Boolean).map((line) => STACK_INDENT + formatPath(trimPaths(line), config, relativeTestPath)).join("\n");
          return renderedCallsite ? `${renderedCallsite}
${stacktrace}` : `
${stacktrace}`;
        }
        function isErrorOrStackWithCause(errorOrStack) {
          return typeof errorOrStack !== "string" && "cause" in errorOrStack && (typeof errorOrStack.cause === "string" || _util.types.isNativeError(errorOrStack.cause) || errorOrStack.cause instanceof Error);
        }
        function formatErrorStack(errorOrStack, config, options, testPath) {
          const sourceStack = typeof errorOrStack === "string" ? errorOrStack : errorOrStack.stack || "";
          let {
            message,
            stack
          } = separateMessageFromStack(sourceStack);
          stack = options.noStackTrace ? "" : `${STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath))}
`;
          message = checkForCommonEnvironmentErrors(message);
          message = indentAllLines(message);
          let cause = "";
          if (isErrorOrStackWithCause(errorOrStack)) {
            const nestedCause = formatErrorStack(errorOrStack.cause, config, options, testPath);
            cause = `
${MESSAGE_INDENT}Cause:
${nestedCause}`;
          }
          return `${message}
${stack}${cause}`;
        }
        function failureDetailsToErrorOrStack(failureDetails, content) {
          if (!failureDetails) {
            return content;
          }
          if (_util.types.isNativeError(failureDetails) || failureDetails instanceof Error) {
            return failureDetails;
          }
          if (typeof failureDetails === "object" && "error" in failureDetails && (_util.types.isNativeError(failureDetails.error) || failureDetails.error instanceof Error)) {
            return failureDetails.error;
          }
          return content;
        }
        const formatResultsErrors = (testResults, config, options, testPath) => {
          const failedResults = testResults.reduce((errors, result) => {
            for (const [index, item] of result.failureMessages.entries()) {
              errors.push({
                content: item,
                failureDetails: result.failureDetails[index],
                result
              });
            }
            return errors;
          }, []);
          if (failedResults.length === 0) {
            return null;
          }
          return failedResults.map(({
            result,
            content,
            failureDetails
          }) => {
            const rootErrorOrStack = failureDetailsToErrorOrStack(failureDetails, content);
            const title = `${_chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length > 0 ? ANCESTRY_SEPARATOR : "") + result.title)}
`;
            return `${title}
${formatErrorStack(rootErrorOrStack, config, options, testPath)}`;
          }).join("\n");
        };
        exports2.formatResultsErrors = formatResultsErrors;
        const errorRegexp = /^Error:?\s*$/;
        const removeBlankErrorLine = (str) => str.split("\n").filter((line) => !errorRegexp.test(line)).join("\n").trimEnd();
        const separateMessageFromStack = (content) => {
          if (!content) {
            return {
              message: "",
              stack: ""
            };
          }
          const messageMatch = content.match(/^(?:Error: )?([\S\s]*?(?=\n\s*at\s.*:\d*:\d*)|\s*.*)([\S\s]*)$/);
          if (!messageMatch) {
            throw new Error("If you hit this error, the regex above is buggy.");
          }
          const message = removeBlankErrorLine(messageMatch[1]);
          const stack = removeBlankErrorLine(messageMatch[2]);
          return {
            message,
            stack
          };
        };
        exports2.separateMessageFromStack = separateMessageFromStack;
      })();
      module.exports = __webpack_exports__;
    })();
  }
});

// node_modules/expect/build/index.js
var require_build7 = __commonJS({
  "node_modules/expect/build/index.js"(exports, module) {
    (() => {
      "use strict";
      var __webpack_modules__ = {
        /***/
        "./src/asymmetricMatchers.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.closeTo = exports2.arrayOf = exports2.arrayNotContaining = exports2.arrayContaining = exports2.anything = exports2.any = exports2.AsymmetricMatcher = void 0;
            exports2.hasProperty = hasProperty;
            exports2.stringNotMatching = exports2.stringNotContaining = exports2.stringMatching = exports2.stringContaining = exports2.objectNotContaining = exports2.objectContaining = exports2.notCloseTo = exports2.notArrayOf = void 0;
            var _expectUtils = require_build5();
            var matcherUtils = _interopRequireWildcard(require_build3());
            var _jestUtil = require_build4();
            var _jestMatchersObject = __webpack_require__2("./src/jestMatchersObject.ts");
            function _interopRequireWildcard(e, t) {
              if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
              return (_interopRequireWildcard = function(e2, t2) {
                if (!t2 && e2 && e2.__esModule) return e2;
                var o, i, f = { __proto__: null, default: e2 };
                if (null === e2 || "object" != typeof e2 && "function" != typeof e2) return f;
                if (o = t2 ? n : r) {
                  if (o.has(e2)) return o.get(e2);
                  o.set(e2, f);
                }
                for (const t3 in e2) "default" !== t3 && {}.hasOwnProperty.call(e2, t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, t3)) && (i.get || i.set) ? o(f, t3, i) : f[t3] = e2[t3]);
                return f;
              })(e, t);
            }
            var Symbol = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
            const functionToString = Function.prototype.toString;
            function fnNameFor(func) {
              if (func.name) {
                return func.name;
              }
              const matches = functionToString.call(func).match(/^(?:async)?\s*function\s*\*?\s*([\w$]+)\s*\(/);
              return matches ? matches[1] : "<anonymous>";
            }
            const utils = Object.freeze({
              ...matcherUtils,
              iterableEquality: _expectUtils.iterableEquality,
              subsetEquality: _expectUtils.subsetEquality
            });
            function hasProperty(obj, property) {
              if (!obj) {
                return false;
              }
              if (Object.prototype.hasOwnProperty.call(obj, property)) {
                return true;
              }
              return hasProperty(Object.getPrototypeOf(obj), property);
            }
            class AsymmetricMatcher2 {
              $$typeof = Symbol.for("jest.asymmetricMatcher");
              constructor(sample, inverse = false) {
                this.sample = sample;
                this.inverse = inverse;
              }
              getMatcherContext() {
                return {
                  customTesters: (0, _jestMatchersObject.getCustomEqualityTesters)(),
                  // eslint-disable-next-line @typescript-eslint/no-empty-function
                  dontThrow: () => {
                  },
                  ...(0, _jestMatchersObject.getState)(),
                  equals: _expectUtils.equals,
                  isNot: this.inverse,
                  utils
                };
              }
            }
            exports2.AsymmetricMatcher = AsymmetricMatcher2;
            class Any extends AsymmetricMatcher2 {
              constructor(sample) {
                if (sample === void 0) {
                  throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
                }
                super(sample);
              }
              asymmetricMatch(other) {
                if (this.sample === String) {
                  return typeof other === "string" || other instanceof String;
                }
                if (this.sample === Number) {
                  return typeof other === "number" || other instanceof Number;
                }
                if (this.sample === Function) {
                  return typeof other === "function" || other instanceof Function;
                }
                if (this.sample === Boolean) {
                  return typeof other === "boolean" || other instanceof Boolean;
                }
                if (this.sample === BigInt) {
                  return typeof other === "bigint" || other instanceof BigInt;
                }
                if (this.sample === Symbol) {
                  return typeof other === "symbol" || other instanceof Symbol;
                }
                if (this.sample === Object) {
                  return typeof other === "object";
                }
                if (this.sample === Array) {
                  return Array.isArray(other);
                }
                return other instanceof this.sample;
              }
              toString() {
                return "Any";
              }
              getExpectedType() {
                if (this.sample === String) {
                  return "string";
                }
                if (this.sample === Number) {
                  return "number";
                }
                if (this.sample === Function) {
                  return "function";
                }
                if (this.sample === Object) {
                  return "object";
                }
                if (this.sample === Boolean) {
                  return "boolean";
                }
                if (this.sample === Array) {
                  return "array";
                }
                return fnNameFor(this.sample);
              }
              toAsymmetricMatcher() {
                return `Any<${fnNameFor(this.sample)}>`;
              }
            }
            class Anything extends AsymmetricMatcher2 {
              asymmetricMatch(other) {
                return other != null;
              }
              toString() {
                return "Anything";
              }
              // No getExpectedType method, because it matches either null or undefined.
              toAsymmetricMatcher() {
                return "Anything";
              }
            }
            class ArrayContaining extends AsymmetricMatcher2 {
              constructor(sample, inverse = false) {
                super(sample, inverse);
              }
              asymmetricMatch(other) {
                if (!Array.isArray(this.sample)) {
                  throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
                }
                const matcherContext = this.getMatcherContext();
                const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => (0, _expectUtils.equals)(item, another, matcherContext.customTesters)));
                return this.inverse ? !result : result;
              }
              toString() {
                return `Array${this.inverse ? "Not" : ""}Containing`;
              }
              getExpectedType() {
                return "array";
              }
            }
            class ArrayOf extends AsymmetricMatcher2 {
              asymmetricMatch(other) {
                const matcherContext = this.getMatcherContext();
                const result = Array.isArray(other) && other.every((item) => (0, _expectUtils.equals)(this.sample, item, matcherContext.customTesters));
                return this.inverse ? !result : result;
              }
              toString() {
                return `${this.inverse ? "Not" : ""}ArrayOf`;
              }
              getExpectedType() {
                return "array";
              }
            }
            class ObjectContaining extends AsymmetricMatcher2 {
              constructor(sample, inverse = false) {
                super(sample, inverse);
              }
              asymmetricMatch(other) {
                if (typeof this.sample !== "object") {
                  throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
                }
                if (typeof other !== "object" || Array.isArray(other)) {
                  return false;
                }
                let result = true;
                const matcherContext = this.getMatcherContext();
                const objectKeys = (0, _expectUtils.getObjectKeys)(this.sample);
                for (const key of objectKeys) {
                  if (!hasProperty(other, key) || !(0, _expectUtils.equals)(this.sample[key], other[key], matcherContext.customTesters)) {
                    result = false;
                    break;
                  }
                }
                return this.inverse ? !result : result;
              }
              toString() {
                return `Object${this.inverse ? "Not" : ""}Containing`;
              }
              getExpectedType() {
                return "object";
              }
            }
            class StringContaining extends AsymmetricMatcher2 {
              constructor(sample, inverse = false) {
                if (!(0, _expectUtils.isA)("String", sample)) {
                  throw new Error("Expected is not a string");
                }
                super(sample, inverse);
              }
              asymmetricMatch(other) {
                const result = (0, _expectUtils.isA)("String", other) && other.includes(this.sample);
                return this.inverse ? !result : result;
              }
              toString() {
                return `String${this.inverse ? "Not" : ""}Containing`;
              }
              getExpectedType() {
                return "string";
              }
            }
            class StringMatching extends AsymmetricMatcher2 {
              constructor(sample, inverse = false) {
                if (!(0, _expectUtils.isA)("String", sample) && !(0, _expectUtils.isA)("RegExp", sample)) {
                  throw new Error("Expected is not a String or a RegExp");
                }
                super(new RegExp(sample), inverse);
              }
              asymmetricMatch(other) {
                const result = (0, _expectUtils.isA)("String", other) && this.sample.test(other);
                return this.inverse ? !result : result;
              }
              toString() {
                return `String${this.inverse ? "Not" : ""}Matching`;
              }
              getExpectedType() {
                return "string";
              }
            }
            class CloseTo extends AsymmetricMatcher2 {
              precision;
              constructor(sample, precision = 2, inverse = false) {
                if (!(0, _expectUtils.isA)("Number", sample)) {
                  throw new Error("Expected is not a Number");
                }
                if (!(0, _expectUtils.isA)("Number", precision)) {
                  throw new Error("Precision is not a Number");
                }
                super(sample);
                this.inverse = inverse;
                this.precision = precision;
              }
              asymmetricMatch(other) {
                if (!(0, _expectUtils.isA)("Number", other)) {
                  return false;
                }
                let result = false;
                if (other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) {
                  result = true;
                } else if (other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY) {
                  result = true;
                } else {
                  result = Math.abs(this.sample - other) < Math.pow(10, -this.precision) / 2;
                }
                return this.inverse ? !result : result;
              }
              toString() {
                return `Number${this.inverse ? "Not" : ""}CloseTo`;
              }
              getExpectedType() {
                return "number";
              }
              toAsymmetricMatcher() {
                return [this.toString(), this.sample, `(${(0, _jestUtil.pluralize)("digit", this.precision)})`].join(" ");
              }
            }
            const any = (expectedObject) => new Any(expectedObject);
            exports2.any = any;
            const anything = () => new Anything();
            exports2.anything = anything;
            const arrayContaining = (sample) => new ArrayContaining(sample);
            exports2.arrayContaining = arrayContaining;
            const arrayNotContaining = (sample) => new ArrayContaining(sample, true);
            exports2.arrayNotContaining = arrayNotContaining;
            const arrayOf = (sample) => new ArrayOf(sample);
            exports2.arrayOf = arrayOf;
            const notArrayOf = (sample) => new ArrayOf(sample, true);
            exports2.notArrayOf = notArrayOf;
            const objectContaining = (sample) => new ObjectContaining(sample);
            exports2.objectContaining = objectContaining;
            const objectNotContaining = (sample) => new ObjectContaining(sample, true);
            exports2.objectNotContaining = objectNotContaining;
            const stringContaining = (expected) => new StringContaining(expected);
            exports2.stringContaining = stringContaining;
            const stringNotContaining = (expected) => new StringContaining(expected, true);
            exports2.stringNotContaining = stringNotContaining;
            const stringMatching = (expected) => new StringMatching(expected);
            exports2.stringMatching = stringMatching;
            const stringNotMatching = (expected) => new StringMatching(expected, true);
            exports2.stringNotMatching = stringNotMatching;
            const closeTo = (expected, precision) => new CloseTo(expected, precision);
            exports2.closeTo = closeTo;
            const notCloseTo = (expected, precision) => new CloseTo(expected, precision, true);
            exports2.notCloseTo = notCloseTo;
          }
        ),
        /***/
        "./src/extractExpectedAssertionsErrors.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2["default"] = void 0;
            var _jestMatcherUtils = require_build3();
            var _jestMatchersObject = __webpack_require__2("./src/jestMatchersObject.ts");
            const resetAssertionsLocalState = () => {
              (0, _jestMatchersObject.setState)({
                assertionCalls: 0,
                expectedAssertionsNumber: null,
                isExpectingAssertions: false,
                numPassingAsserts: 0
              });
            };
            const extractExpectedAssertionsErrors = () => {
              const result = [];
              const {
                assertionCalls,
                expectedAssertionsNumber,
                expectedAssertionsNumberError,
                isExpectingAssertions,
                isExpectingAssertionsError
              } = (0, _jestMatchersObject.getState)();
              resetAssertionsLocalState();
              if (typeof expectedAssertionsNumber === "number" && assertionCalls !== expectedAssertionsNumber) {
                const numOfAssertionsExpected = (0, _jestMatcherUtils.EXPECTED_COLOR)((0, _jestMatcherUtils.pluralize)("assertion", expectedAssertionsNumber));
                expectedAssertionsNumberError.message = `${(0, _jestMatcherUtils.matcherHint)(".assertions", "", expectedAssertionsNumber.toString(), {
                  isDirectExpectCall: true
                })}

Expected ${numOfAssertionsExpected} to be called but received ${(0, _jestMatcherUtils.RECEIVED_COLOR)((0, _jestMatcherUtils.pluralize)("assertion call", assertionCalls || 0))}.`;
                result.push({
                  actual: assertionCalls.toString(),
                  error: expectedAssertionsNumberError,
                  expected: expectedAssertionsNumber.toString()
                });
              }
              if (isExpectingAssertions && assertionCalls === 0) {
                const expected = (0, _jestMatcherUtils.EXPECTED_COLOR)("at least one assertion");
                const received = (0, _jestMatcherUtils.RECEIVED_COLOR)("received none");
                isExpectingAssertionsError.message = `${(0, _jestMatcherUtils.matcherHint)(".hasAssertions", "", "", {
                  isDirectExpectCall: true
                })}

Expected ${expected} to be called but ${received}.`;
                result.push({
                  actual: "none",
                  error: isExpectingAssertionsError,
                  expected: "at least one"
                });
              }
              return result;
            };
            var _default = exports2["default"] = extractExpectedAssertionsErrors;
          }
        ),
        /***/
        "./src/jestMatchersObject.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.setState = exports2.setMatchers = exports2.getState = exports2.getMatchers = exports2.getCustomEqualityTesters = exports2.addCustomEqualityTesters = exports2.INTERNAL_MATCHER_FLAG = void 0;
            var _getType = require_build();
            var _asymmetricMatchers = __webpack_require__2("./src/asymmetricMatchers.ts");
            var Symbol = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
            const JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object");
            const INTERNAL_MATCHER_FLAG = exports2.INTERNAL_MATCHER_FLAG = Symbol.for("$$jest-internal-matcher");
            if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
              const defaultState = {
                assertionCalls: 0,
                expectedAssertionsNumber: null,
                isExpectingAssertions: false,
                numPassingAsserts: 0,
                suppressedErrors: []
                // errors that are not thrown immediately.
              };
              Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
                value: {
                  customEqualityTesters: [],
                  matchers: /* @__PURE__ */ Object.create(null),
                  state: defaultState
                }
              });
            }
            const getState = () => globalThis[JEST_MATCHERS_OBJECT].state;
            exports2.getState = getState;
            const setState = (state) => {
              Object.assign(globalThis[JEST_MATCHERS_OBJECT].state, state);
            };
            exports2.setState = setState;
            const getMatchers = () => globalThis[JEST_MATCHERS_OBJECT].matchers;
            exports2.getMatchers = getMatchers;
            const setMatchers = (matchers, isInternal, expect2) => {
              for (const key of Object.keys(matchers)) {
                const matcher = matchers[key];
                if (typeof matcher !== "function") {
                  throw new TypeError(`expect.extend: \`${key}\` is not a valid matcher. Must be a function, is "${(0, _getType.getType)(matcher)}"`);
                }
                Object.defineProperty(matcher, INTERNAL_MATCHER_FLAG, {
                  value: isInternal
                });
                if (!isInternal) {
                  class CustomMatcher extends _asymmetricMatchers.AsymmetricMatcher {
                    constructor(inverse = false, ...sample) {
                      super(sample, inverse);
                    }
                    asymmetricMatch(other) {
                      const {
                        pass
                      } = matcher.call(this.getMatcherContext(), other, ...this.sample);
                      return this.inverse ? !pass : pass;
                    }
                    toString() {
                      return `${this.inverse ? "not." : ""}${key}`;
                    }
                    getExpectedType() {
                      return "any";
                    }
                    toAsymmetricMatcher() {
                      return `${this.toString()}<${this.sample.map(String).join(", ")}>`;
                    }
                  }
                  Object.defineProperty(expect2, key, {
                    configurable: true,
                    enumerable: true,
                    value: (...sample) => new CustomMatcher(false, ...sample),
                    writable: true
                  });
                  Object.defineProperty(expect2.not, key, {
                    configurable: true,
                    enumerable: true,
                    value: (...sample) => new CustomMatcher(true, ...sample),
                    writable: true
                  });
                }
              }
              Object.assign(globalThis[JEST_MATCHERS_OBJECT].matchers, matchers);
            };
            exports2.setMatchers = setMatchers;
            const getCustomEqualityTesters = () => globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
            exports2.getCustomEqualityTesters = getCustomEqualityTesters;
            const addCustomEqualityTesters = (newTesters) => {
              if (!Array.isArray(newTesters)) {
                throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${(0, _getType.getType)(newTesters)}"`);
              }
              globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters.push(...newTesters);
            };
            exports2.addCustomEqualityTesters = addCustomEqualityTesters;
          }
        ),
        /***/
        "./src/matchers.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2["default"] = void 0;
            var _expectUtils = require_build5();
            var _getType = require_build();
            var _jestMatcherUtils = require_build3();
            var _print = __webpack_require__2("./src/print.ts");
            const EXPECTED_LABEL = "Expected";
            const RECEIVED_LABEL = "Received";
            const EXPECTED_VALUE_LABEL = "Expected value";
            const RECEIVED_VALUE_LABEL = "Received value";
            const isExpand = (expand) => expand !== false;
            const toStrictEqualTesters = [_expectUtils.iterableEquality, _expectUtils.typeEquality, _expectUtils.sparseArrayEquality, _expectUtils.arrayBufferEquality];
            const matchers = {
              toBe(received, expected) {
                const matcherName = "toBe";
                const options = {
                  comment: "Object.is equality",
                  isNot: this.isNot,
                  promise: this.promise
                };
                const pass = Object.is(received, expected);
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}`
                ) : () => {
                  const expectedType = (0, _getType.getType)(expected);
                  let deepEqualityName = null;
                  if (expectedType !== "map" && expectedType !== "set") {
                    if ((0, _expectUtils.equals)(received, expected, [...this.customTesters, ...toStrictEqualTesters], true)) {
                      deepEqualityName = "toStrictEqual";
                    } else if ((0, _expectUtils.equals)(received, expected, [...this.customTesters, _expectUtils.iterableEquality])) {
                      deepEqualityName = "toEqual";
                    }
                  }
                  return (
                    // eslint-disable-next-line prefer-template
                    (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (deepEqualityName === null ? "" : `${(0, _jestMatcherUtils.DIM_COLOR)(`If it should pass with deep equality, replace "${matcherName}" with "${deepEqualityName}"`)}

`) + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand))
                  );
                };
                return {
                  actual: received,
                  expected,
                  message,
                  name: matcherName,
                  pass
                };
              },
              toBeCloseTo(received, expected, precision = 2) {
                const matcherName = "toBeCloseTo";
                const secondArgument = arguments.length === 3 ? "precision" : void 0;
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise,
                  secondArgument,
                  secondArgumentColor: (arg) => arg
                };
                if (typeof expected !== "number") {
                  throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a number`, (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected)));
                }
                if (typeof received !== "number") {
                  throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a number`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                let pass = false;
                let expectedDiff = 0;
                let receivedDiff = 0;
                if (received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY) {
                  pass = true;
                } else if (received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY) {
                  pass = true;
                } else {
                  expectedDiff = Math.pow(10, -precision) / 2;
                  receivedDiff = Math.abs(expected - received);
                  pass = receivedDiff < expectedDiff;
                }
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + (receivedDiff === 0 ? "" : `Received:     ${(0, _jestMatcherUtils.printReceived)(received)}

${(0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot)}`)
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
Received: ${(0, _jestMatcherUtils.printReceived)(received)}

` + (0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot)
                );
                return {
                  message,
                  pass
                };
              },
              toBeDefined(received, expected) {
                const matcherName = "toBeDefined";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = received !== void 0;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeFalsy(received, expected) {
                const matcherName = "toBeFalsy";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = !received;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeGreaterThan(received, expected) {
                const matcherName = "toBeGreaterThan";
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
                const pass = received > expected;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected:${isNot ? " not" : ""} > ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}   ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeGreaterThanOrEqual(received, expected) {
                const matcherName = "toBeGreaterThanOrEqual";
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
                const pass = received >= expected;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected:${isNot ? " not" : ""} >= ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}    ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeInstanceOf(received, expected) {
                const matcherName = "toBeInstanceOf";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                if (typeof expected !== "function") {
                  throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a function`, (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected)));
                }
                const pass = received instanceof expected;
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _print.printExpectedConstructorNameNot)("Expected constructor", expected) + (typeof received.constructor === "function" && received.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)("Received constructor", received.constructor, expected) : "")
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _print.printExpectedConstructorName)("Expected constructor", expected) + ((0, _getType.isPrimitive)(received) || Object.getPrototypeOf(received) === null ? `
Received value has no prototype
Received value: ${(0, _jestMatcherUtils.printReceived)(received)}` : typeof received.constructor === "function" ? (0, _print.printReceivedConstructorName)("Received constructor", received.constructor) : `
Received value: ${(0, _jestMatcherUtils.printReceived)(received)}`)
                );
                return {
                  message,
                  pass
                };
              },
              toBeLessThan(received, expected) {
                const matcherName = "toBeLessThan";
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
                const pass = received < expected;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected:${isNot ? " not" : ""} < ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}   ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeLessThanOrEqual(received, expected) {
                const matcherName = "toBeLessThanOrEqual";
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
                const pass = received <= expected;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected:${isNot ? " not" : ""} <= ${(0, _jestMatcherUtils.printExpected)(expected)}
Received:${isNot ? "    " : ""}    ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeNaN(received, expected) {
                const matcherName = "toBeNaN";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = Number.isNaN(received);
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeNull(received, expected) {
                const matcherName = "toBeNull";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = received === null;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeTruthy(received, expected) {
                const matcherName = "toBeTruthy";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = !!received;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toBeUndefined(received, expected) {
                const matcherName = "toBeUndefined";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
                const pass = received === void 0;
                const message = () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + `

Received: ${(0, _jestMatcherUtils.printReceived)(received)}`
                );
                return {
                  message,
                  pass
                };
              },
              toContain(received, expected) {
                const matcherName = "toContain";
                const isNot = this.isNot;
                const options = {
                  comment: "indexOf",
                  isNot,
                  promise: this.promise
                };
                if (received == null) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must not be null nor undefined`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                if (typeof received === "string") {
                  const wrongTypeErrorMessage = `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a string if ${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value is a string`;
                  if (typeof expected !== "string") {
                    throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)(
                      (0, _jestMatcherUtils.matcherHint)(matcherName, received, String(expected), options),
                      wrongTypeErrorMessage,
                      // eslint-disable-next-line prefer-template
                      (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected) + "\n" + (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)
                    ));
                  }
                  const index2 = received.indexOf(String(expected));
                  const pass2 = index2 !== -1;
                  const message2 = () => {
                    const labelExpected = `Expected ${typeof expected === "string" ? "substring" : "value"}`;
                    const labelReceived = "Received string";
                    const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
                    return (
                      // eslint-disable-next-line prefer-template
                      (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot ? (0, _print.printReceivedStringContainExpectedSubstring)(received, index2, String(expected).length) : (0, _jestMatcherUtils.printReceived)(received)}`
                    );
                  };
                  return {
                    message: message2,
                    pass: pass2
                  };
                }
                const indexable = [...received];
                const index = indexable.indexOf(expected);
                const pass = index !== -1;
                const message = () => {
                  const labelExpected = "Expected value";
                  const labelReceived = `Received ${(0, _getType.getType)(received)}`;
                  const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
                  return (
                    // eslint-disable-next-line prefer-template
                    (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)}` + (!isNot && indexable.some((item) => (0, _expectUtils.equals)(item, expected, [...this.customTesters, _expectUtils.iterableEquality])) ? `

${_jestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL}` : "")
                  );
                };
                return {
                  message,
                  pass
                };
              },
              toContainEqual(received, expected) {
                const matcherName = "toContainEqual";
                const isNot = this.isNot;
                const options = {
                  comment: "deep equality",
                  isNot,
                  promise: this.promise
                };
                if (received == null) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must not be null nor undefined`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                const index = [...received].findIndex((item) => (0, _expectUtils.equals)(item, expected, [...this.customTesters, _expectUtils.iterableEquality]));
                const pass = index !== -1;
                const message = () => {
                  const labelExpected = "Expected value";
                  const labelReceived = `Received ${(0, _getType.getType)(received)}`;
                  const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
                  return (
                    // eslint-disable-next-line prefer-template
                    (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${isNot ? "    " : ""}${isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)}`
                  );
                };
                return {
                  message,
                  pass
                };
              },
              toEqual(received, expected) {
                const matcherName = "toEqual";
                const options = {
                  comment: "deep equality",
                  isNot: this.isNot,
                  promise: this.promise
                };
                const pass = (0, _expectUtils.equals)(received, expected, [...this.customTesters, _expectUtils.iterableEquality]);
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + ((0, _jestMatcherUtils.stringify)(expected) === (0, _jestMatcherUtils.stringify)(received) ? "" : `Received:     ${(0, _jestMatcherUtils.printReceived)(received)}`)
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand))
                );
                return {
                  actual: received,
                  expected,
                  message,
                  name: matcherName,
                  pass
                };
              },
              toHaveLength(received, expected) {
                const matcherName = "toHaveLength";
                const isNot = this.isNot;
                const options = {
                  isNot,
                  promise: this.promise
                };
                if (typeof received?.length !== "number") {
                  throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must have a length property whose value must be a number`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);
                const pass = received.length === expected;
                const message = () => {
                  const labelExpected = "Expected length";
                  const labelReceivedLength = "Received length";
                  const labelReceivedValue = `Received ${(0, _getType.getType)(received)}`;
                  const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceivedLength, labelReceivedValue);
                  return (
                    // eslint-disable-next-line prefer-template
                    (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

${printLabel(labelExpected)}${isNot ? "not " : ""}${(0, _jestMatcherUtils.printExpected)(expected)}
` + (isNot ? "" : `${printLabel(labelReceivedLength)}${(0, _jestMatcherUtils.printReceived)(received.length)}
`) + `${printLabel(labelReceivedValue)}${isNot ? "    " : ""}${(0, _jestMatcherUtils.printReceived)(received)}`
                  );
                };
                return {
                  message,
                  pass
                };
              },
              toHaveProperty(received, expectedPath, expectedValue) {
                const matcherName = "toHaveProperty";
                const expectedArgument = "path";
                const hasValue = arguments.length === 3;
                const options = {
                  isNot: this.isNot,
                  promise: this.promise,
                  secondArgument: hasValue ? "value" : ""
                };
                if (received === null || received === void 0) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must not be null nor undefined`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                const expectedPathType = (0, _getType.getType)(expectedPath);
                if (expectedPathType !== "string" && expectedPathType !== "array") {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} path must be a string or array`, (0, _jestMatcherUtils.printWithType)("Expected", expectedPath, _jestMatcherUtils.printExpected)));
                }
                const expectedPathLength = typeof expectedPath === "string" ? (0, _expectUtils.pathAsArray)(expectedPath).length : expectedPath.length;
                if (expectedPathType === "array" && expectedPathLength === 0) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} path must not be an empty array`, (0, _jestMatcherUtils.printWithType)("Expected", expectedPath, _jestMatcherUtils.printExpected)));
                }
                const result = (0, _expectUtils.getPath)(received, expectedPath);
                const {
                  lastTraversedObject,
                  endPropIsDefined,
                  hasEndProp,
                  value
                } = result;
                const receivedPath = result.traversedPath;
                const hasCompletePath = receivedPath.length === expectedPathLength;
                const receivedValue = hasCompletePath ? result.value : lastTraversedObject;
                const pass = hasValue && endPropIsDefined ? (0, _expectUtils.equals)(value, expectedValue, [...this.customTesters, _expectUtils.iterableEquality]) : Boolean(hasEndProp);
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options) + "\n\n" + (hasValue ? `Expected path: ${(0, _jestMatcherUtils.printExpected)(expectedPath)}

Expected value: not ${(0, _jestMatcherUtils.printExpected)(expectedValue)}${(0, _jestMatcherUtils.stringify)(expectedValue) === (0, _jestMatcherUtils.stringify)(receivedValue) ? "" : `
Received value:     ${(0, _jestMatcherUtils.printReceived)(receivedValue)}`}` : `Expected path: not ${(0, _jestMatcherUtils.printExpected)(expectedPath)}

Received value: ${(0, _jestMatcherUtils.printReceived)(receivedValue)}`)
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options) + `

Expected path: ${(0, _jestMatcherUtils.printExpected)(expectedPath)}
` + (hasCompletePath ? `
${(0, _jestMatcherUtils.printDiffOrStringify)(expectedValue, receivedValue, EXPECTED_VALUE_LABEL, RECEIVED_VALUE_LABEL, isExpand(this.expand))}` : `Received path: ${(0, _jestMatcherUtils.printReceived)(expectedPathType === "array" || receivedPath.length === 0 ? receivedPath : receivedPath.join("."))}

${hasValue ? `Expected value: ${(0, _jestMatcherUtils.printExpected)(expectedValue)}
` : ""}Received value: ${(0, _jestMatcherUtils.printReceived)(receivedValue)}`)
                );
                return {
                  message,
                  pass
                };
              },
              toMatch(received, expected) {
                const matcherName = "toMatch";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                if (typeof received !== "string") {
                  throw new TypeError((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a string`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                if (!(typeof expected === "string") && !(expected && typeof expected.test === "function")) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a string or regular expression`, (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected)));
                }
                const pass = typeof expected === "string" ? received.includes(expected) : new RegExp(expected).test(received);
                const message = pass ? () => typeof expected === "string" ? (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected substring: not ${(0, _jestMatcherUtils.printExpected)(expected)}
Received string:        ${(0, _print.printReceivedStringContainExpectedSubstring)(received, received.indexOf(expected), expected.length)}`
                ) : (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected pattern: not ${(0, _jestMatcherUtils.printExpected)(expected)}
Received string:      ${(0, _print.printReceivedStringContainExpectedResult)(received, typeof expected.exec === "function" ? expected.exec(received) : null)}`
                ) : () => {
                  const labelExpected = `Expected ${typeof expected === "string" ? "substring" : "pattern"}`;
                  const labelReceived = "Received string";
                  const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
                  return (
                    // eslint-disable-next-line prefer-template
                    (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

${printLabel(labelExpected)}${(0, _jestMatcherUtils.printExpected)(expected)}
${printLabel(labelReceived)}${(0, _jestMatcherUtils.printReceived)(received)}`
                  );
                };
                return {
                  message,
                  pass
                };
              },
              toMatchObject(received, expected) {
                const matcherName = "toMatchObject";
                const options = {
                  isNot: this.isNot,
                  promise: this.promise
                };
                if (typeof received !== "object" || received === null) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a non-null object`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                }
                if (typeof expected !== "object" || expected === null) {
                  throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a non-null object`, (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected)));
                }
                const pass = (0, _expectUtils.equals)(received, expected, [...this.customTesters, _expectUtils.iterableEquality, _expectUtils.subsetEquality]);
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}` + ((0, _jestMatcherUtils.stringify)(expected) === (0, _jestMatcherUtils.stringify)(received) ? "" : `
Received:     ${(0, _jestMatcherUtils.printReceived)(received)}`)
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(expected, (0, _expectUtils.getObjectSubset)(received, expected, this.customTesters), EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand))
                );
                return {
                  message,
                  pass
                };
              },
              toStrictEqual(received, expected) {
                const matcherName = "toStrictEqual";
                const options = {
                  comment: "deep equality",
                  isNot: this.isNot,
                  promise: this.promise
                };
                const pass = (0, _expectUtils.equals)(received, expected, [...this.customTesters, ...toStrictEqualTesters], true);
                const message = pass ? () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + ((0, _jestMatcherUtils.stringify)(expected) === (0, _jestMatcherUtils.stringify)(received) ? "" : `Received:     ${(0, _jestMatcherUtils.printReceived)(received)}`)
                ) : () => (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand))
                );
                return {
                  actual: received,
                  expected,
                  message,
                  name: matcherName,
                  pass
                };
              }
            };
            var _default = exports2["default"] = matchers;
          }
        ),
        /***/
        "./src/print.ts": (
          /***/
          (__unused_webpack_module, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.printReceivedStringContainExpectedSubstring = exports2.printReceivedStringContainExpectedResult = exports2.printReceivedConstructorNameNot = exports2.printReceivedConstructorName = exports2.printReceivedArrayContainExpectedItem = exports2.printExpectedConstructorNameNot = exports2.printExpectedConstructorName = exports2.printCloseTo = void 0;
            var _jestMatcherUtils = require_build3();
            const printSubstring = (val) => val.replaceAll(/"|\\/g, "\\$&");
            const printReceivedStringContainExpectedSubstring = (received, start, length) => (0, _jestMatcherUtils.RECEIVED_COLOR)(`"${printSubstring(received.slice(0, start))}${(0, _jestMatcherUtils.INVERTED_COLOR)(printSubstring(received.slice(start, start + length)))}${printSubstring(received.slice(start + length))}"`);
            exports2.printReceivedStringContainExpectedSubstring = printReceivedStringContainExpectedSubstring;
            const printReceivedStringContainExpectedResult = (received, result) => result === null ? (0, _jestMatcherUtils.printReceived)(received) : printReceivedStringContainExpectedSubstring(received, result.index, result[0].length);
            exports2.printReceivedStringContainExpectedResult = printReceivedStringContainExpectedResult;
            const printReceivedArrayContainExpectedItem = (received, index) => (0, _jestMatcherUtils.RECEIVED_COLOR)(`[${received.map((item, i) => {
              const stringified = (0, _jestMatcherUtils.stringify)(item);
              return i === index ? (0, _jestMatcherUtils.INVERTED_COLOR)(stringified) : stringified;
            }).join(", ")}]`);
            exports2.printReceivedArrayContainExpectedItem = printReceivedArrayContainExpectedItem;
            const printCloseTo = (receivedDiff, expectedDiff, precision, isNot) => {
              const receivedDiffString = (0, _jestMatcherUtils.stringify)(receivedDiff);
              const expectedDiffString = receivedDiffString.includes("e") ? (
                // toExponential arg is number of digits after the decimal point.
                expectedDiff.toExponential(0)
              ) : 0 <= precision && precision < 20 ? (
                // toFixed arg is number of digits after the decimal point.
                // It may be a value between 0 and 20 inclusive.
                // Implementations may optionally support a larger range of values.
                expectedDiff.toFixed(precision + 1)
              ) : (0, _jestMatcherUtils.stringify)(expectedDiff);
              return `Expected precision:  ${isNot ? "    " : ""}  ${(0, _jestMatcherUtils.stringify)(precision)}
Expected difference: ${isNot ? "not " : ""}< ${(0, _jestMatcherUtils.EXPECTED_COLOR)(expectedDiffString)}
Received difference: ${isNot ? "    " : ""}  ${(0, _jestMatcherUtils.RECEIVED_COLOR)(receivedDiffString)}`;
            };
            exports2.printCloseTo = printCloseTo;
            const printExpectedConstructorName = (label, expected) => `${printConstructorName(label, expected, false, true)}
`;
            exports2.printExpectedConstructorName = printExpectedConstructorName;
            const printExpectedConstructorNameNot = (label, expected) => `${printConstructorName(label, expected, true, true)}
`;
            exports2.printExpectedConstructorNameNot = printExpectedConstructorNameNot;
            const printReceivedConstructorName = (label, received) => `${printConstructorName(label, received, false, false)}
`;
            exports2.printReceivedConstructorName = printReceivedConstructorName;
            const printReceivedConstructorNameNot = (label, received, expected) => typeof expected.name === "string" && expected.name.length > 0 && typeof received.name === "string" && received.name.length > 0 ? `${printConstructorName(label, received, true, false)} ${Object.getPrototypeOf(received) === expected ? "extends" : "extends … extends"} ${(0, _jestMatcherUtils.EXPECTED_COLOR)(expected.name)}
` : `${printConstructorName(label, received, false, false)}
`;
            exports2.printReceivedConstructorNameNot = printReceivedConstructorNameNot;
            const printConstructorName = (label, constructor, isNot, isExpected) => typeof constructor.name === "string" ? constructor.name.length === 0 ? `${label} name is an empty string` : `${label}: ${isNot ? isExpected ? "not " : "    " : ""}${isExpected ? (0, _jestMatcherUtils.EXPECTED_COLOR)(constructor.name) : (0, _jestMatcherUtils.RECEIVED_COLOR)(constructor.name)}` : `${label} name is not a string`;
          }
        ),
        /***/
        "./src/spyMatchers.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2["default"] = void 0;
            var _expectUtils = require_build5();
            var _getType = require_build();
            var _jestMatcherUtils = require_build3();
            var _jestMatchersObject = __webpack_require__2("./src/jestMatchersObject.ts");
            const isExpand = (expand) => expand !== false;
            const PRINT_LIMIT = 3;
            const NO_ARGUMENTS = "called with 0 arguments";
            const printExpectedArgs = (expected) => expected.length === 0 ? NO_ARGUMENTS : expected.map((arg) => (0, _jestMatcherUtils.printExpected)(arg)).join(", ");
            const printReceivedArgs = (received, expected) => received.length === 0 ? NO_ARGUMENTS : received.map((arg, i) => Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg)).join(", ");
            const printCommon = (val) => (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));
            const isEqualValue = (expected, received) => (0, _expectUtils.equals)(expected, received, [...(0, _jestMatchersObject.getCustomEqualityTesters)(), _expectUtils.iterableEquality]);
            const isEqualCall = (expected, received) => received.length === expected.length && isEqualValue(expected, received);
            const isEqualReturn = (expected, result) => result.type === "return" && isEqualValue(expected, result.value);
            const countReturns = (results) => results.reduce((n, result) => result.type === "return" ? n + 1 : n, 0);
            const printNumberOfReturns = (countReturns2, countCalls) => `
Number of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns2)}${countCalls === countReturns2 ? "" : `
Number of calls:   ${(0, _jestMatcherUtils.printReceived)(countCalls)}`}`;
            const getRightAlignedPrinter = (label) => {
              const index = label.indexOf(":");
              const suffix = label.slice(index);
              return (string, isExpectedCall) => (isExpectedCall ? `->${" ".repeat(Math.max(0, index - 2 - string.length))}` : " ".repeat(Math.max(index - string.length))) + string + suffix;
            };
            const printReceivedCallsNegative = (expected, indexedCalls, isOnlyCall, iExpectedCall) => {
              if (indexedCalls.length === 0) {
                return "";
              }
              const label = "Received:     ";
              if (isOnlyCall) {
                return `${label + printReceivedArgs(indexedCalls[0], expected)}
`;
              }
              const printAligned = getRightAlignedPrinter(label);
              return `Received
${indexedCalls.reduce((printed, [i, args]) => `${printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected)}
`, "")}`;
            };
            const printExpectedReceivedCallsPositive = (expected, indexedCalls, expand, isOnlyCall, iExpectedCall) => {
              const expectedLine = `Expected: ${printExpectedArgs(expected)}
`;
              if (indexedCalls.length === 0) {
                return expectedLine;
              }
              const label = "Received: ";
              if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === void 0)) {
                const received = indexedCalls[0][1];
                if (isLineDiffableCall(expected, received)) {
                  const lines = [(0, _jestMatcherUtils.EXPECTED_COLOR)("- Expected"), (0, _jestMatcherUtils.RECEIVED_COLOR)("+ Received"), ""];
                  const length = Math.max(expected.length, received.length);
                  for (let i = 0; i < length; i += 1) {
                    if (i < expected.length && i < received.length) {
                      if (isEqualValue(expected[i], received[i])) {
                        lines.push(`  ${printCommon(received[i])},`);
                        continue;
                      }
                      if (isLineDiffableArg(expected[i], received[i])) {
                        const difference = (0, _jestMatcherUtils.diff)(expected[i], received[i], {
                          expand
                        });
                        if (typeof difference === "string" && difference.includes("- Expected") && difference.includes("+ Received")) {
                          lines.push(`${difference.split("\n").slice(3).join("\n")},`);
                          continue;
                        }
                      }
                    }
                    if (i < expected.length) {
                      lines.push(`${(0, _jestMatcherUtils.EXPECTED_COLOR)(`- ${(0, _jestMatcherUtils.stringify)(expected[i])}`)},`);
                    }
                    if (i < received.length) {
                      lines.push(`${(0, _jestMatcherUtils.RECEIVED_COLOR)(`+ ${(0, _jestMatcherUtils.stringify)(received[i])}`)},`);
                    }
                  }
                  return `${lines.join("\n")}
`;
                }
                return `${expectedLine + label + printReceivedArgs(received, expected)}
`;
              }
              const printAligned = getRightAlignedPrinter(label);
              return (
                // eslint-disable-next-line prefer-template
                expectedLine + "Received\n" + indexedCalls.reduce((printed, [i, received]) => {
                  const aligned = printAligned(String(i + 1), i === iExpectedCall);
                  return `${printed + ((i === iExpectedCall || iExpectedCall === void 0) && isLineDiffableCall(expected, received) ? aligned.replace(": ", "\n") + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected))}
`;
                }, "")
              );
            };
            const indentation = "Received".replaceAll(/\w/g, " ");
            const printDiffCall = (expected, received, expand) => received.map((arg, i) => {
              if (i < expected.length) {
                if (isEqualValue(expected[i], arg)) {
                  return `${indentation}  ${printCommon(arg)},`;
                }
                if (isLineDiffableArg(expected[i], arg)) {
                  const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {
                    expand
                  });
                  if (typeof difference === "string" && difference.includes("- Expected") && difference.includes("+ Received")) {
                    return `${difference.split("\n").slice(3).map((line) => indentation + line).join("\n")},`;
                  }
                }
              }
              return `${indentation + (i < expected.length ? `  ${(0, _jestMatcherUtils.printReceived)(arg)}` : (0, _jestMatcherUtils.RECEIVED_COLOR)(`+ ${(0, _jestMatcherUtils.stringify)(arg)}`))},`;
            }).join("\n");
            const isLineDiffableCall = (expected, received) => expected.some((arg, i) => i < received.length && isLineDiffableArg(arg, received[i]));
            const isLineDiffableArg = (expected, received) => {
              const expectedType = (0, _getType.getType)(expected);
              const receivedType = (0, _getType.getType)(received);
              if (expectedType !== receivedType) {
                return false;
              }
              if ((0, _getType.isPrimitive)(expected)) {
                return false;
              }
              if (expectedType === "date" || expectedType === "function" || expectedType === "regexp") {
                return false;
              }
              if (expected instanceof Error && received instanceof Error) {
                return false;
              }
              if (expectedType === "object" && typeof expected.asymmetricMatch === "function") {
                return false;
              }
              if (receivedType === "object" && typeof received.asymmetricMatch === "function") {
                return false;
              }
              return true;
            };
            const printResult = (result, expected) => result.type === "throw" ? "function call threw an error" : result.type === "incomplete" ? "function call has not returned yet" : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value);
            const printReceivedResults = (label, expected, indexedResults, isOnlyCall, iExpectedCall) => {
              if (indexedResults.length === 0) {
                return "";
              }
              if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === void 0)) {
                return `${label + printResult(indexedResults[0][1], expected)}
`;
              }
              const printAligned = getRightAlignedPrinter(label);
              return (
                // eslint-disable-next-line prefer-template
                label.replace(":", "").trim() + "\n" + indexedResults.reduce((printed, [i, result]) => `${printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected)}
`, "")
              );
            };
            const createToHaveBeenCalledMatcher = () => function(received, expected) {
              const expectedArgument = "";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              (0, _jestMatcherUtils.ensureNoExpected)(expected, "toHaveBeenCalled", options);
              ensureMockOrSpy(received, "toHaveBeenCalled", expectedArgument, options);
              const receivedIsSpy = isSpy(received);
              const receivedName = receivedIsSpy ? "spy" : received.getMockName();
              const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
              const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
              const pass = count > 0;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalled", receivedName, expectedArgument, options) + `

Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(0)}
Received number of calls: ${(0, _jestMatcherUtils.printReceived)(count)}

` + calls.reduce((lines, args, i) => {
                  if (lines.length < PRINT_LIMIT) {
                    lines.push(`${i + 1}: ${printReceivedArgs(args)}`);
                  }
                  return lines;
                }, []).join("\n")
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalled", receivedName, expectedArgument, options) + `

Expected number of calls: >= ${(0, _jestMatcherUtils.printExpected)(1)}
Received number of calls:    ${(0, _jestMatcherUtils.printReceived)(count)}`
              );
              return {
                message,
                pass
              };
            };
            const createToHaveReturnedMatcher = () => function(received, expected) {
              const expectedArgument = "";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              (0, _jestMatcherUtils.ensureNoExpected)(expected, "toHaveReturned", options);
              ensureMock(received, "toHaveReturned", expectedArgument, options);
              const receivedName = received.getMockName();
              const count = received.mock.results.reduce((n, result) => result.type === "return" ? n + 1 : n, 0);
              const pass = count > 0;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveReturned", receivedName, expectedArgument, options) + `

Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(0)}
Received number of returns: ${(0, _jestMatcherUtils.printReceived)(count)}

` + received.mock.results.reduce((lines, result, i) => {
                  if (result.type === "return" && lines.length < PRINT_LIMIT) {
                    lines.push(`${i + 1}: ${(0, _jestMatcherUtils.printReceived)(result.value)}`);
                  }
                  return lines;
                }, []).join("\n") + (received.mock.calls.length === count ? "" : `

Received number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}`)
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveReturned", receivedName, expectedArgument, options) + `

Expected number of returns: >= ${(0, _jestMatcherUtils.printExpected)(1)}
Received number of returns:    ${(0, _jestMatcherUtils.printReceived)(count)}` + (received.mock.calls.length === count ? "" : `
Received number of calls:      ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}`)
              );
              return {
                message,
                pass
              };
            };
            const createToHaveBeenCalledTimesMatcher = () => function(received, expected) {
              const expectedArgument = "expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, "toHaveBeenCalledTimes", options);
              ensureMockOrSpy(received, "toHaveBeenCalledTimes", expectedArgument, options);
              const receivedIsSpy = isSpy(received);
              const receivedName = receivedIsSpy ? "spy" : received.getMockName();
              const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
              const pass = count === expected;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalledTimes", receivedName, expectedArgument, options) + `

Expected number of calls: not ${(0, _jestMatcherUtils.printExpected)(expected)}`
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalledTimes", receivedName, expectedArgument, options) + `

Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(expected)}
Received number of calls: ${(0, _jestMatcherUtils.printReceived)(count)}`
              );
              return {
                message,
                pass
              };
            };
            const createToHaveReturnedTimesMatcher = () => function(received, expected) {
              const expectedArgument = "expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, "toHaveReturnedTimes", options);
              ensureMock(received, "toHaveReturnedTimes", expectedArgument, options);
              const receivedName = received.getMockName();
              const count = received.mock.results.reduce((n, result) => result.type === "return" ? n + 1 : n, 0);
              const pass = count === expected;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveReturnedTimes", receivedName, expectedArgument, options) + `

Expected number of returns: not ${(0, _jestMatcherUtils.printExpected)(expected)}` + (received.mock.calls.length === count ? "" : `

Received number of calls:       ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}`)
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)("toHaveReturnedTimes", receivedName, expectedArgument, options) + `

Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(expected)}
Received number of returns: ${(0, _jestMatcherUtils.printReceived)(count)}` + (received.mock.calls.length === count ? "" : `
Received number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}`)
              );
              return {
                message,
                pass
              };
            };
            const createToHaveBeenCalledWithMatcher = () => function(received, ...expected) {
              const expectedArgument = "...expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              ensureMockOrSpy(received, "toHaveBeenCalledWith", expectedArgument, options);
              const receivedIsSpy = isSpy(received);
              const receivedName = receivedIsSpy ? "spy" : received.getMockName();
              const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
              const pass = calls.some((call) => isEqualCall(expected, call));
              const message = pass ? () => {
                const indexedCalls = [];
                let i = 0;
                while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
                  if (isEqualCall(expected, calls[i])) {
                    indexedCalls.push([i, calls[i]]);
                  }
                  i += 1;
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalledWith", receivedName, expectedArgument, options) + `

Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1)) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              } : () => {
                const indexedCalls = [];
                let i = 0;
                while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
                  indexedCalls.push([i, calls[i]]);
                  i += 1;
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenCalledWith", receivedName, expectedArgument, options) + "\n\n" + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              };
              return {
                message,
                pass
              };
            };
            const createToHaveReturnedWithMatcher = () => function(received, expected) {
              const expectedArgument = "expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              ensureMock(received, "toHaveReturnedWith", expectedArgument, options);
              const receivedName = received.getMockName();
              const {
                calls,
                results
              } = received.mock;
              const pass = results.some((result) => isEqualReturn(expected, result));
              const message = pass ? () => {
                const indexedResults = [];
                let i = 0;
                while (i < results.length && indexedResults.length < PRINT_LIMIT) {
                  if (isEqualReturn(expected, results[i])) {
                    indexedResults.push([i, results[i]]);
                  }
                  i += 1;
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveReturnedWith", receivedName, expectedArgument, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults("Received:     ", expected, indexedResults, results.length === 1)) + printNumberOfReturns(countReturns(results), calls.length)
                );
              } : () => {
                const indexedResults = [];
                let i = 0;
                while (i < results.length && indexedResults.length < PRINT_LIMIT) {
                  indexedResults.push([i, results[i]]);
                  i += 1;
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveReturnedWith", receivedName, expectedArgument, options) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults("Received: ", expected, indexedResults, results.length === 1) + printNumberOfReturns(countReturns(results), calls.length)
                );
              };
              return {
                message,
                pass
              };
            };
            const createToHaveBeenLastCalledWithMatcher = () => function(received, ...expected) {
              const expectedArgument = "...expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              ensureMockOrSpy(received, "toHaveBeenLastCalledWith", expectedArgument, options);
              const receivedIsSpy = isSpy(received);
              const receivedName = receivedIsSpy ? "spy" : received.getMockName();
              const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
              const iLast = calls.length - 1;
              const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);
              const message = pass ? () => {
                const indexedCalls = [];
                if (iLast > 0) {
                  indexedCalls.push([iLast - 1, calls[iLast - 1]]);
                }
                indexedCalls.push([iLast, calls[iLast]]);
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenLastCalledWith", receivedName, expectedArgument, options) + `

Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iLast)) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              } : () => {
                const indexedCalls = [];
                if (iLast >= 0) {
                  if (iLast > 0) {
                    let i = iLast - 1;
                    while (i >= 0 && !isEqualCall(expected, calls[i])) {
                      i -= 1;
                    }
                    if (i < 0) {
                      i = iLast - 1;
                    }
                    indexedCalls.push([i, calls[i]]);
                  }
                  indexedCalls.push([iLast, calls[iLast]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenLastCalledWith", receivedName, expectedArgument, options) + "\n\n" + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iLast) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              };
              return {
                message,
                pass
              };
            };
            const createToHaveLastReturnedWithMatcher = () => function(received, expected) {
              const expectedArgument = "expected";
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              ensureMock(received, "toHaveLastReturnedWith", expectedArgument, options);
              const receivedName = received.getMockName();
              const {
                calls,
                results
              } = received.mock;
              const iLast = results.length - 1;
              const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);
              const message = pass ? () => {
                const indexedResults = [];
                if (iLast > 0) {
                  indexedResults.push([iLast - 1, results[iLast - 1]]);
                }
                indexedResults.push([iLast, results[iLast]]);
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveLastReturnedWith", receivedName, expectedArgument, options) + `

Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults("Received:     ", expected, indexedResults, results.length === 1, iLast)) + printNumberOfReturns(countReturns(results), calls.length)
                );
              } : () => {
                const indexedResults = [];
                if (iLast >= 0) {
                  if (iLast > 0) {
                    let i = iLast - 1;
                    while (i >= 0 && !isEqualReturn(expected, results[i])) {
                      i -= 1;
                    }
                    if (i < 0) {
                      i = iLast - 1;
                    }
                    indexedResults.push([i, results[i]]);
                  }
                  indexedResults.push([iLast, results[iLast]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveLastReturnedWith", receivedName, expectedArgument, options) + `

Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults("Received: ", expected, indexedResults, results.length === 1, iLast) + printNumberOfReturns(countReturns(results), calls.length)
                );
              };
              return {
                message,
                pass
              };
            };
            const createToHaveBeenNthCalledWithMatcher = () => function(received, nth, ...expected) {
              const expectedArgument = "n";
              const options = {
                expectedColor: (arg) => arg,
                isNot: this.isNot,
                promise: this.promise,
                secondArgument: "...expected"
              };
              ensureMockOrSpy(received, "toHaveBeenNthCalledWith", expectedArgument, options);
              if (!Number.isSafeInteger(nth) || nth < 1) {
                throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)("toHaveBeenNthCalledWith", void 0, expectedArgument, options), `${expectedArgument} must be a positive integer`, (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));
              }
              const receivedIsSpy = isSpy(received);
              const receivedName = receivedIsSpy ? "spy" : received.getMockName();
              const calls = receivedIsSpy ? received.calls.all().map((x) => x.args) : received.mock.calls;
              const length = calls.length;
              const iNth = nth - 1;
              const pass = iNth < length && isEqualCall(expected, calls[iNth]);
              const message = pass ? () => {
                const indexedCalls = [];
                if (iNth - 1 >= 0) {
                  indexedCalls.push([iNth - 1, calls[iNth - 1]]);
                }
                indexedCalls.push([iNth, calls[iNth]]);
                if (iNth + 1 < length) {
                  indexedCalls.push([iNth + 1, calls[iNth + 1]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenNthCalledWith", receivedName, expectedArgument, options) + `

n: ${nth}
Expected: not ${printExpectedArgs(expected)}
` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iNth)) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              } : () => {
                const indexedCalls = [];
                if (iNth < length) {
                  if (iNth - 1 >= 0) {
                    let i = iNth - 1;
                    while (i >= 0 && !isEqualCall(expected, calls[i])) {
                      i -= 1;
                    }
                    if (i < 0) {
                      i = iNth - 1;
                    }
                    indexedCalls.push([i, calls[i]]);
                  }
                  indexedCalls.push([iNth, calls[iNth]]);
                  if (iNth + 1 < length) {
                    let i = iNth + 1;
                    while (i < length && !isEqualCall(expected, calls[i])) {
                      i += 1;
                    }
                    if (i >= length) {
                      i = iNth + 1;
                    }
                    indexedCalls.push([i, calls[i]]);
                  }
                } else if (length > 0) {
                  let i = length - 1;
                  while (i >= 0 && !isEqualCall(expected, calls[i])) {
                    i -= 1;
                  }
                  if (i < 0) {
                    i = length - 1;
                  }
                  indexedCalls.push([i, calls[i]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveBeenNthCalledWith", receivedName, expectedArgument, options) + `

n: ${nth}
` + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iNth) + `
Number of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`
                );
              };
              return {
                message,
                pass
              };
            };
            const createToHaveNthReturnedWithMatcher = () => function(received, nth, expected) {
              const expectedArgument = "n";
              const options = {
                expectedColor: (arg) => arg,
                isNot: this.isNot,
                promise: this.promise,
                secondArgument: "expected"
              };
              ensureMock(received, "toHaveNthReturnedWith", expectedArgument, options);
              if (!Number.isSafeInteger(nth) || nth < 1) {
                throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)("toHaveNthReturnedWith", void 0, expectedArgument, options), `${expectedArgument} must be a positive integer`, (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));
              }
              const receivedName = received.getMockName();
              const {
                calls,
                results
              } = received.mock;
              const length = results.length;
              const iNth = nth - 1;
              const pass = iNth < length && isEqualReturn(expected, results[iNth]);
              const message = pass ? () => {
                const indexedResults = [];
                if (iNth - 1 >= 0) {
                  indexedResults.push([iNth - 1, results[iNth - 1]]);
                }
                indexedResults.push([iNth, results[iNth]]);
                if (iNth + 1 < length) {
                  indexedResults.push([iNth + 1, results[iNth + 1]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveNthReturnedWith", receivedName, expectedArgument, options) + `

n: ${nth}
Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}
` + (results.length === 1 && results[0].type === "return" && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? "" : printReceivedResults("Received:     ", expected, indexedResults, results.length === 1, iNth)) + printNumberOfReturns(countReturns(results), calls.length)
                );
              } : () => {
                const indexedResults = [];
                if (iNth < length) {
                  if (iNth - 1 >= 0) {
                    let i = iNth - 1;
                    while (i >= 0 && !isEqualReturn(expected, results[i])) {
                      i -= 1;
                    }
                    if (i < 0) {
                      i = iNth - 1;
                    }
                    indexedResults.push([i, results[i]]);
                  }
                  indexedResults.push([iNth, results[iNth]]);
                  if (iNth + 1 < length) {
                    let i = iNth + 1;
                    while (i < length && !isEqualReturn(expected, results[i])) {
                      i += 1;
                    }
                    if (i >= length) {
                      i = iNth + 1;
                    }
                    indexedResults.push([i, results[i]]);
                  }
                } else if (length > 0) {
                  let i = length - 1;
                  while (i >= 0 && !isEqualReturn(expected, results[i])) {
                    i -= 1;
                  }
                  if (i < 0) {
                    i = length - 1;
                  }
                  indexedResults.push([i, results[i]]);
                }
                return (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.matcherHint)("toHaveNthReturnedWith", receivedName, expectedArgument, options) + `

n: ${nth}
Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}
` + printReceivedResults("Received: ", expected, indexedResults, results.length === 1, iNth) + printNumberOfReturns(countReturns(results), calls.length)
                );
              };
              return {
                message,
                pass
              };
            };
            const spyMatchers = {
              toHaveBeenCalled: createToHaveBeenCalledMatcher(),
              toHaveBeenCalledTimes: createToHaveBeenCalledTimesMatcher(),
              toHaveBeenCalledWith: createToHaveBeenCalledWithMatcher(),
              toHaveBeenLastCalledWith: createToHaveBeenLastCalledWithMatcher(),
              toHaveBeenNthCalledWith: createToHaveBeenNthCalledWithMatcher(),
              toHaveLastReturnedWith: createToHaveLastReturnedWithMatcher(),
              toHaveNthReturnedWith: createToHaveNthReturnedWithMatcher(),
              toHaveReturned: createToHaveReturnedMatcher(),
              toHaveReturnedTimes: createToHaveReturnedTimesMatcher(),
              toHaveReturnedWith: createToHaveReturnedWithMatcher()
            };
            const isMock = (received) => received != null && received._isMockFunction === true;
            const isSpy = (received) => received != null && received.calls != null && typeof received.calls.all === "function" && typeof received.calls.count === "function";
            const ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {
              if (!isMock(received) && !isSpy(received)) {
                throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a mock or spy function`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
              }
            };
            const ensureMock = (received, matcherName, expectedArgument, options) => {
              if (!isMock(received)) {
                throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, expectedArgument, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a mock function`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
              }
            };
            var _default = exports2["default"] = spyMatchers;
          }
        ),
        /***/
        "./src/toThrowMatchers.ts": (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2["default"] = exports2.createMatcher = void 0;
            var _expectUtils = require_build5();
            var _jestMatcherUtils = require_build3();
            var _jestMessageUtil = require_build6();
            var _print = __webpack_require__2("./src/print.ts");
            const DID_NOT_THROW = "Received function did not throw";
            const getThrown = (e) => {
              const hasMessage = e !== null && e !== void 0 && typeof e.message === "string";
              if (hasMessage && typeof e.name === "string" && typeof e.stack === "string") {
                return {
                  hasMessage,
                  isError: true,
                  message: e.message,
                  value: e
                };
              }
              return {
                hasMessage,
                isError: false,
                message: hasMessage ? e.message : String(e),
                value: e
              };
            };
            const createMatcher = (matcherName, fromPromise) => function(received, expected) {
              const options = {
                isNot: this.isNot,
                promise: this.promise
              };
              let thrown = null;
              if (fromPromise && (0, _expectUtils.isError)(received)) {
                thrown = getThrown(received);
              } else {
                if (typeof received === "function") {
                  try {
                    received();
                  } catch (error) {
                    thrown = getThrown(error);
                  }
                } else {
                  if (!fromPromise) {
                    const placeholder = expected === void 0 ? "" : "expected";
                    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, placeholder, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)("received")} value must be a function`, (0, _jestMatcherUtils.printWithType)("Received", received, _jestMatcherUtils.printReceived)));
                  }
                }
              }
              if (expected === void 0) {
                return toThrow(matcherName, options, thrown);
              } else if (typeof expected === "function") {
                return toThrowExpectedClass(matcherName, options, thrown, expected);
              } else if (typeof expected === "string") {
                return toThrowExpectedString(matcherName, options, thrown, expected);
              } else if (expected !== null && typeof expected.test === "function") {
                return toThrowExpectedRegExp(matcherName, options, thrown, expected);
              } else if (expected !== null && typeof expected.asymmetricMatch === "function") {
                return toThrowExpectedAsymmetric(matcherName, options, thrown, expected);
              } else if (expected !== null && typeof expected === "object") {
                return toThrowExpectedObject(matcherName, options, thrown, expected);
              } else {
                throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options), `${(0, _jestMatcherUtils.EXPECTED_COLOR)("expected")} value must be a string or regular expression or class or error`, (0, _jestMatcherUtils.printWithType)("Expected", expected, _jestMatcherUtils.printExpected)));
              }
            };
            exports2.createMatcher = createMatcher;
            const matchers = {
              toThrow: createMatcher("toThrow")
            };
            const toThrowExpectedRegExp = (matcherName, options, thrown, expected) => {
              const pass = thrown !== null && expected.test(thrown.message);
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected pattern: not ", expected) + (thrown !== null && thrown.hasMessage ? formatReceived("Received message:     ", thrown, "message", expected) + formatStack(thrown) : formatReceived("Received value:       ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected pattern: ", expected) + (thrown === null ? `
${DID_NOT_THROW}` : thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value:   ", thrown, "value"))
              );
              return {
                message,
                pass
              };
            };
            const toThrowExpectedAsymmetric = (matcherName, options, thrown, expected) => {
              const pass = thrown !== null && expected.asymmetricMatch(thrown.value);
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected asymmetric matcher: not ", expected) + "\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Received name:    ", thrown, "name") + formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected asymmetric matcher: ", expected) + "\n" + (thrown === null ? DID_NOT_THROW : thrown.hasMessage ? formatReceived("Received name:    ", thrown, "name") + formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value"))
              );
              return {
                message,
                pass
              };
            };
            const toThrowExpectedObject = (matcherName, options, thrown, expected) => {
              const expectedMessageAndCause = createMessageAndCause(expected);
              const thrownMessageAndCause = thrown === null ? null : createMessageAndCause(thrown.value);
              const isCompareErrorInstance = thrown?.isError && expected instanceof Error;
              const isExpectedCustomErrorInstance = expected.constructor.name !== Error.name;
              const pass = thrown !== null && thrown.message === expected.message && thrownMessageAndCause === expectedMessageAndCause && (!isCompareErrorInstance || !isExpectedCustomErrorInstance || thrown.value instanceof expected.constructor);
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected(`Expected ${messageAndCause(expected)}: not `, expectedMessageAndCause) + (thrown !== null && thrown.hasMessage ? formatStack(thrown) : formatReceived("Received value:       ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (thrown === null ? (
                  // eslint-disable-next-line prefer-template
                  formatExpected(`Expected ${messageAndCause(expected)}: `, expectedMessageAndCause) + "\n" + DID_NOT_THROW
                ) : thrown.hasMessage ? (
                  // eslint-disable-next-line prefer-template
                  (0, _jestMatcherUtils.printDiffOrStringify)(expectedMessageAndCause, thrownMessageAndCause, `Expected ${messageAndCause(expected)}`, `Received ${messageAndCause(thrown.value)}`, true) + "\n" + formatStack(thrown)
                ) : formatExpected(`Expected ${messageAndCause(expected)}: `, expectedMessageAndCause) + formatReceived("Received value:   ", thrown, "value"))
              );
              return {
                message,
                pass
              };
            };
            const toThrowExpectedClass = (matcherName, options, thrown, expected) => {
              const pass = thrown !== null && thrown.value instanceof expected;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _print.printExpectedConstructorNameNot)("Expected constructor", expected) + (thrown !== null && thrown.value != null && typeof thrown.value.constructor === "function" && thrown.value.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)("Received constructor", thrown.value.constructor, expected) : "") + "\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value: ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + (0, _print.printExpectedConstructorName)("Expected constructor", expected) + (thrown === null ? `
${DID_NOT_THROW}` : `${thrown.value != null && typeof thrown.value.constructor === "function" ? (0, _print.printReceivedConstructorName)("Received constructor", thrown.value.constructor) : ""}
${thrown.hasMessage ? formatReceived("Received message: ", thrown, "message") + formatStack(thrown) : formatReceived("Received value: ", thrown, "value")}`)
              );
              return {
                message,
                pass
              };
            };
            const toThrowExpectedString = (matcherName, options, thrown, expected) => {
              const pass = thrown !== null && thrown.message.includes(expected);
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected substring: not ", expected) + (thrown !== null && thrown.hasMessage ? formatReceived("Received message:       ", thrown, "message", expected) + formatStack(thrown) : formatReceived("Received value:         ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, void 0, options) + "\n\n" + formatExpected("Expected substring: ", expected) + (thrown === null ? `
${DID_NOT_THROW}` : thrown.hasMessage ? formatReceived("Received message:   ", thrown, "message") + formatStack(thrown) : formatReceived("Received value:     ", thrown, "value"))
              );
              return {
                message,
                pass
              };
            };
            const toThrow = (matcherName, options, thrown) => {
              const pass = thrown !== null;
              const message = pass ? () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + "\n\n" + (thrown !== null && thrown.hasMessage ? formatReceived("Error name:    ", thrown, "name") + formatReceived("Error message: ", thrown, "message") + formatStack(thrown) : formatReceived("Thrown value: ", thrown, "value"))
              ) : () => (
                // eslint-disable-next-line prefer-template
                (0, _jestMatcherUtils.matcherHint)(matcherName, void 0, "", options) + "\n\n" + DID_NOT_THROW
              );
              return {
                message,
                pass
              };
            };
            const formatExpected = (label, expected) => `${label + (0, _jestMatcherUtils.printExpected)(expected)}
`;
            const formatReceived = (label, thrown, key, expected) => {
              if (thrown === null) {
                return "";
              }
              if (key === "message") {
                const message = thrown.message;
                if (typeof expected === "string") {
                  const index = message.indexOf(expected);
                  if (index !== -1) {
                    return `${label + (0, _print.printReceivedStringContainExpectedSubstring)(message, index, expected.length)}
`;
                  }
                } else if (expected instanceof RegExp) {
                  return `${label + (0, _print.printReceivedStringContainExpectedResult)(message, typeof expected.exec === "function" ? expected.exec(message) : null)}
`;
                }
                return `${label + (0, _jestMatcherUtils.printReceived)(message)}
`;
              }
              if (key === "name") {
                return thrown.isError ? `${label + (0, _jestMatcherUtils.printReceived)(thrown.value.name)}
` : "";
              }
              if (key === "value") {
                return thrown.isError ? "" : `${label + (0, _jestMatcherUtils.printReceived)(thrown.value)}
`;
              }
              return "";
            };
            const formatStack = (thrown) => {
              if (thrown === null || !thrown.isError) {
                return "";
              } else {
                const config = {
                  rootDir: process.cwd(),
                  testMatch: []
                };
                const options = {
                  noStackTrace: false
                };
                if (thrown.value instanceof AggregateError) {
                  return (0, _jestMessageUtil.formatExecError)(thrown.value, config, options);
                } else {
                  return (0, _jestMessageUtil.formatStackTrace)((0, _jestMessageUtil.separateMessageFromStack)(thrown.value.stack).stack, config, options);
                }
              }
            };
            function createMessageAndCause(error) {
              if (error.cause) {
                const seen = /* @__PURE__ */ new WeakSet();
                return JSON.stringify(buildSerializeError(error), (_, value) => {
                  if (isObject(value)) {
                    if (seen.has(value)) return;
                    seen.add(value);
                  }
                  return value === void 0 ? String(void 0) : value;
                });
              }
              return error.message;
            }
            function buildSerializeError(error) {
              if (!isObject(error)) {
                return error;
              }
              const result = {};
              for (const name of Object.getOwnPropertyNames(error).sort()) {
                if (["stack", "fileName", "lineNumber"].includes(name)) {
                  continue;
                }
                if (name === "cause") {
                  result[name] = buildSerializeError(error["cause"]);
                  continue;
                }
                result[name] = error[name];
              }
              return result;
            }
            function isObject(obj) {
              return obj != null && typeof obj === "object";
            }
            function messageAndCause(error) {
              return error.cause === void 0 ? "message" : "message and cause";
            }
            var _default = exports2["default"] = matchers;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      var __webpack_exports__ = {};
      (() => {
        var exports2 = __webpack_exports__;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "AsymmetricMatcher", {
          enumerable: true,
          get: function() {
            return _asymmetricMatchers.AsymmetricMatcher;
          }
        });
        exports2.expect = exports2["default"] = exports2.JestAssertionError = void 0;
        var _expectUtils = require_build5();
        var matcherUtils = _interopRequireWildcard(require_build3());
        var _jestUtil = require_build4();
        var _asymmetricMatchers = __webpack_require__("./src/asymmetricMatchers.ts");
        var _extractExpectedAssertionsErrors = _interopRequireDefault(__webpack_require__("./src/extractExpectedAssertionsErrors.ts"));
        var _jestMatchersObject = __webpack_require__("./src/jestMatchersObject.ts");
        var _matchers = _interopRequireDefault(__webpack_require__("./src/matchers.ts"));
        var _spyMatchers = _interopRequireDefault(__webpack_require__("./src/spyMatchers.ts"));
        var _toThrowMatchers = _interopRequireWildcard(__webpack_require__("./src/toThrowMatchers.ts"));
        function _interopRequireDefault(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function _interopRequireWildcard(e, t) {
          if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
          return (_interopRequireWildcard = function(e2, t2) {
            if (!t2 && e2 && e2.__esModule) return e2;
            var o, i, f = { __proto__: null, default: e2 };
            if (null === e2 || "object" != typeof e2 && "function" != typeof e2) return f;
            if (o = t2 ? n : r) {
              if (o.has(e2)) return o.get(e2);
              o.set(e2, f);
            }
            for (const t3 in e2) "default" !== t3 && {}.hasOwnProperty.call(e2, t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, t3)) && (i.get || i.set) ? o(f, t3, i) : f[t3] = e2[t3]);
            return f;
          })(e, t);
        }
        class JestAssertionError2 extends Error {
          matcherResult;
        }
        exports2.JestAssertionError = JestAssertionError2;
        const createToThrowErrorMatchingSnapshotMatcher = function(matcher) {
          return function(received, testNameOrInlineSnapshot) {
            return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);
          };
        };
        const getPromiseMatcher = (name, matcher) => {
          if (name === "toThrow") {
            return (0, _toThrowMatchers.createMatcher)(name, true);
          } else if (name === "toThrowErrorMatchingSnapshot" || name === "toThrowErrorMatchingInlineSnapshot") {
            return createToThrowErrorMatchingSnapshotMatcher(matcher);
          }
          return null;
        };
        const expect2 = (actual, ...rest) => {
          if (rest.length > 0) {
            throw new Error("Expect takes at most one argument.");
          }
          const allMatchers = (0, _jestMatchersObject.getMatchers)();
          const expectation = {
            not: {},
            rejects: {
              not: {}
            },
            resolves: {
              not: {}
            }
          };
          const err = new JestAssertionError2();
          for (const name of Object.keys(allMatchers)) {
            const matcher = allMatchers[name];
            const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;
            expectation[name] = makeThrowingMatcher(matcher, false, "", actual);
            expectation.not[name] = makeThrowingMatcher(matcher, true, "", actual);
            expectation.resolves[name] = makeResolveMatcher(name, promiseMatcher, false, actual, err);
            expectation.resolves.not[name] = makeResolveMatcher(name, promiseMatcher, true, actual, err);
            expectation.rejects[name] = makeRejectMatcher(name, promiseMatcher, false, actual, err);
            expectation.rejects.not[name] = makeRejectMatcher(name, promiseMatcher, true, actual, err);
          }
          return expectation;
        };
        exports2.expect = expect2;
        const getMessage = (message) => message && message() || matcherUtils.RECEIVED_COLOR("No message was specified for this matcher.");
        const makeResolveMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {
          const options = {
            isNot,
            promise: "resolves"
          };
          if (!(0, _jestUtil.isPromise)(actual)) {
            throw new JestAssertionError2(matcherUtils.matcherErrorMessage(matcherUtils.matcherHint(matcherName, void 0, "", options), `${matcherUtils.RECEIVED_COLOR("received")} value must be a promise`, matcherUtils.printWithType("Received", actual, matcherUtils.printReceived)));
          }
          const innerErr = new JestAssertionError2();
          return actual.then((result) => makeThrowingMatcher(matcher, isNot, "resolves", result, innerErr).apply(null, args), (error) => {
            outerErr.message = `${matcherUtils.matcherHint(matcherName, void 0, "", options)}

Received promise rejected instead of resolved
Rejected to value: ${matcherUtils.printReceived(error)}`;
            throw outerErr;
          });
        };
        const makeRejectMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {
          const options = {
            isNot,
            promise: "rejects"
          };
          const actualWrapper = typeof actual === "function" ? actual() : actual;
          if (!(0, _jestUtil.isPromise)(actualWrapper)) {
            throw new JestAssertionError2(matcherUtils.matcherErrorMessage(matcherUtils.matcherHint(matcherName, void 0, "", options), `${matcherUtils.RECEIVED_COLOR("received")} value must be a promise or a function returning a promise`, matcherUtils.printWithType("Received", actual, matcherUtils.printReceived)));
          }
          const innerErr = new JestAssertionError2();
          return actualWrapper.then((result) => {
            outerErr.message = `${matcherUtils.matcherHint(matcherName, void 0, "", options)}

Received promise resolved instead of rejected
Resolved to value: ${matcherUtils.printReceived(result)}`;
            throw outerErr;
          }, (error) => makeThrowingMatcher(matcher, isNot, "rejects", error, innerErr).apply(null, args));
        };
        const makeThrowingMatcher = (matcher, isNot, promise, actual, err) => function throwingMatcher(...args) {
          let throws = true;
          const utils = {
            ...matcherUtils,
            iterableEquality: _expectUtils.iterableEquality,
            subsetEquality: _expectUtils.subsetEquality
          };
          const matcherUtilsThing = {
            customTesters: (0, _jestMatchersObject.getCustomEqualityTesters)(),
            // When throws is disabled, the matcher will not throw errors during test
            // execution but instead add them to the global matcher state. If a
            // matcher throws, test execution is normally stopped immediately. The
            // snapshot matcher uses it because we want to log all snapshot
            // failures in a test.
            dontThrow: () => throws = false,
            equals: _expectUtils.equals,
            utils
          };
          const matcherContext = {
            ...(0, _jestMatchersObject.getState)(),
            ...matcherUtilsThing,
            error: err,
            isNot,
            promise
          };
          const processResult = (result, asyncError) => {
            _validateResult(result);
            (0, _jestMatchersObject.getState)().assertionCalls++;
            if (result.pass && isNot || !result.pass && !isNot) {
              const message = getMessage(result.message);
              let error;
              if (err) {
                error = err;
                error.message = message;
              } else if (asyncError) {
                error = asyncError;
                error.message = message;
              } else {
                error = new JestAssertionError2(message);
                if (Error.captureStackTrace) {
                  Error.captureStackTrace(error, throwingMatcher);
                }
              }
              error.matcherResult = {
                ...result,
                message
              };
              if (throws) {
                throw error;
              } else {
                (0, _jestMatchersObject.getState)().suppressedErrors.push(error);
              }
            } else {
              (0, _jestMatchersObject.getState)().numPassingAsserts++;
            }
          };
          const handleError = (error) => {
            if (matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true && !(error instanceof JestAssertionError2) && error.name !== "PrettyFormatPluginError" && // Guard for some environments (browsers) that do not support this feature.
            Error.captureStackTrace) {
              Error.captureStackTrace(error, throwingMatcher);
            }
            throw error;
          };
          let potentialResult;
          try {
            potentialResult = matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true ? matcher.call(matcherContext, actual, ...args) : (
              // It's a trap specifically for inline snapshot to capture this name
              // in the stack trace, so that it can correctly get the custom matcher
              // function call.
              function __EXTERNAL_MATCHER_TRAP__() {
                return matcher.call(matcherContext, actual, ...args);
              }()
            );
            if ((0, _jestUtil.isPromise)(potentialResult)) {
              const asyncError = new JestAssertionError2();
              if (Error.captureStackTrace) {
                Error.captureStackTrace(asyncError, throwingMatcher);
              }
              return potentialResult.then((aResult) => processResult(aResult, asyncError)).catch(handleError);
            } else {
              return processResult(potentialResult);
            }
          } catch (error) {
            return handleError(error);
          }
        };
        expect2.extend = (matchers) => (0, _jestMatchersObject.setMatchers)(matchers, false, expect2);
        expect2.addEqualityTesters = (customTesters) => (0, _jestMatchersObject.addCustomEqualityTesters)(customTesters);
        expect2.anything = _asymmetricMatchers.anything;
        expect2.any = _asymmetricMatchers.any;
        expect2.not = {
          arrayContaining: _asymmetricMatchers.arrayNotContaining,
          arrayOf: _asymmetricMatchers.notArrayOf,
          closeTo: _asymmetricMatchers.notCloseTo,
          objectContaining: _asymmetricMatchers.objectNotContaining,
          stringContaining: _asymmetricMatchers.stringNotContaining,
          stringMatching: _asymmetricMatchers.stringNotMatching
        };
        expect2.arrayContaining = _asymmetricMatchers.arrayContaining;
        expect2.arrayOf = _asymmetricMatchers.arrayOf;
        expect2.closeTo = _asymmetricMatchers.closeTo;
        expect2.objectContaining = _asymmetricMatchers.objectContaining;
        expect2.stringContaining = _asymmetricMatchers.stringContaining;
        expect2.stringMatching = _asymmetricMatchers.stringMatching;
        const _validateResult = (result) => {
          if (typeof result !== "object" || typeof result.pass !== "boolean" || result.message && typeof result.message !== "string" && typeof result.message !== "function") {
            throw new Error(`Unexpected return from a matcher function.
Matcher functions should return an object in the following format:
  {message?: string | function, pass: boolean}
'${matcherUtils.stringify(result)}' was returned`);
          }
        };
        function assertions(expected) {
          const error = new _jestUtil.ErrorWithStack(void 0, assertions);
          (0, _jestMatchersObject.setState)({
            expectedAssertionsNumber: expected,
            expectedAssertionsNumberError: error
          });
        }
        function hasAssertions(...args) {
          const error = new _jestUtil.ErrorWithStack(void 0, hasAssertions);
          matcherUtils.ensureNoExpected(args[0], ".hasAssertions");
          (0, _jestMatchersObject.setState)({
            isExpectingAssertions: true,
            isExpectingAssertionsError: error
          });
        }
        (0, _jestMatchersObject.setMatchers)(_matchers.default, true, expect2);
        (0, _jestMatchersObject.setMatchers)(_spyMatchers.default, true, expect2);
        (0, _jestMatchersObject.setMatchers)(_toThrowMatchers.default, true, expect2);
        expect2.assertions = assertions;
        expect2.hasAssertions = hasAssertions;
        expect2.getState = _jestMatchersObject.getState;
        expect2.setState = _jestMatchersObject.setState;
        expect2.extractExpectedAssertionsErrors = _extractExpectedAssertionsErrors.default;
        var _default = exports2["default"] = expect2;
      })();
      module.exports = __webpack_exports__;
    })();
  }
});

// node_modules/expect/build/index.mjs
var import_index = __toESM(require_build7(), 1);
var AsymmetricMatcher = import_index.default.AsymmetricMatcher;
var JestAssertionError = import_index.default.JestAssertionError;
var expect = import_index.default.expect;
var build_default = import_index.default.default;
export {
  AsymmetricMatcher,
  JestAssertionError,
  build_default as default,
  expect
};
/*! Bundled license information:

@jest/expect-utils/build/index.js:
  (*!
   * /**
   *  * Copyright (c) Meta Platforms, Inc. and affiliates.
   *  *
   *  * This source code is licensed under the MIT license found in the
   *  * LICENSE file in the root directory of this source tree.
   *  * /
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

jest-message-util/build/index.js:
  (*!
   * /**
   *  * Copyright (c) Meta Platforms, Inc. and affiliates.
   *  *
   *  * This source code is licensed under the MIT license found in the
   *  * LICENSE file in the root directory of this source tree.
   *  * /
   *)

expect/build/index.js:
  (*!
   * /**
   *  * Copyright (c) Meta Platforms, Inc. and affiliates.
   *  *
   *  * This source code is licensed under the MIT license found in the
   *  * LICENSE file in the root directory of this source tree.
   *  * /
   *)
*/
//# sourceMappingURL=expect.js.map
